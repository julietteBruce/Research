needsPackage "InverseSystems"

F0E0 =  S = ZZ/101[x,y]

F0E1 =  2*x^2 == toDividedPowers (x^2)

F1E0 =  S = QQ[x,y]

F1E1 =  J = inverseSystem x^2

F1E2 =  J' = inverseSystem (x+y)^2

F1E3 =  J'' = inverseSystem(matrix{{(x+y)^2}}, DividedPowers=>true)

F1E4 =  betti res J''

F1E5 =  kk = QQ

F1E6 =  n = 3

F1E7 =  S = kk[a,b,c]

F1E8 =  M = matrix{{a^2,b^3+c^3}}

F1E9 =  G = random(S^3, S^3)

F1E10 =  g = map(S,S,(vars S)*G)

F1E11 =  g' = map(S,S,(vars S)*(transpose G))

F1E12 =  h =  map(S,S,(vars S)*(transpose G)^(-1))

F1E13 =  inverseSystem M

F1E14 =  g'(inverseSystem g(M))

F1E15 =  g'(inverseSystem g(M)) == inverseSystem M

F1E16 =  h(inverseSystem M) == inverseSystem g(M)

F1E17 =  S = ZZ/101[a,b,c]

F1E18 =  M = random(S^{0,1}, S^{-1,-1,-2,-2})

F1E19 =  d = 6

F1E20 =  N = inverseSystem(d, M)

F1E21 =  image M == inverseSystem N

F1E22 =  d = 5

F1E23 =  N = inverseSystem(d, M)

F1E24 =  image M != inverseSystem N

F1E25 =  M = random(S^{0,1}, S^{-1,-1,-2,-2})

F1E26 =  inverseSystem(inverseSystem(d,gens inverseSystem M)) == inverseSystem M

F2E0 =  S = ZZ/101[x,y]

F2E1 =  f1 = x^2

F2E2 =  f2 = (x+y)^2

F2E3 =  betti res ideal fromDual f1

F2E4 =  betti res ideal fromDual f2

F2E5 =  betti res (I = ideal fromDual(f2, DividedPowers => false))

F2E6 =  I == inverseSystem (f2, DividedPowers => false)

F2E7 =  inverseSystem (f2, DividedPowers => true)

F2E8 =  ideal fromDual(f2, DividedPowers => false)

F2E9 =  ideal fromDual(f2, DividedPowers => true)

F3E0 =  S = ZZ/101[a,b,c,d]

F3E1 =  nPowers = (S, n,d) ->sum(apply(n, j->(random(1,S))^d))

F3E2 =  minimalBetti inverseSystem nPowers(S,4,3)

F3E3 =  minimalBetti inverseSystem nPowers (S,5,3)

F3E4 =  Msymm = matrix"0,a,b

F3E5 =  Mskew = matrix"0,a,b

F3E6 =  minimalBetti coker gens inverseSystem Msymm

F3E7 =  minimalBetti coker gens inverseSystem Mskew

F3E8 =  Hessian = (d,f) ->(

         S = ring f;

         B = basis(d,S);

         diff(transpose B, diff(B,f))

         )

F3E9 =  S = ZZ/101[x_1..x_4]

F3E10 =  f = nPowers (S,6,4)

F3E11 =  minimalBetti coker gens inverseSystem f

F3E12 =  minimalBetti coker gens inverseSystem Hessian(1, f)

F3E13 =  minimalBetti coker gens inverseSystem Hessian(2, f)

F4E0 =  setRandomSeed 0

F4E1 =  kk = QQ

F4E2 =  S = kk[a,b,c]

F4E3 =  map(S,S,0_S*vars S)

F4E4 =  p = (a+b)^2

F4E5 =  q = toDividedPowers p

F4E6 =  p' = fromDividedPowers q

F4E7 =  p'==p

F4E8 =  kk = ZZ/101

F4E9 =  S = kk[a..d]

F4E10 =  f1 = matrix"a2b2+c2d2"; -- gives 1,4,6,4,1

F4E11 =  f2 = matrix"a2b2+b2c2+c2d2"

F4E12 =  f3 = matrix"a2b2+b2c2+c2d2+c2a2"; -- gives 1,4,8,4,1

F4E13 =  f4 = matrix"a2b2+b2c2+c2d2+c2a2+a2d2"; --gives 1,4,8,4,1

F4E14 =  f5 = matrix"a2b2+b2c2+c2d2+c2a2+a2d2+b2d2+b4"; --gives 1,4,9,4,1

F4E15 =  f6 = matrix"a2b2+b2c2+c2d2+c2a2+a2d2+b2d2"; --gives 1,4,10,4,1

F4E16 =  F = {f1,f2,f3,f4,f5,f6};

F4E17 =  netList (F/(f->betti res inverseSystem f))

F5E0 =  S = ZZ/101[x,y]

F5E1 =  x^2 == fromDividedPowers (2*x^2)

exampleIDS = {"F0E0", "F0E1", "F1E0", "F1E1", "F1E2", "F1E3", "F1E4", "F1E5", "F1E6", "F1E7", "F1E8", "F1E9", "F1E10", "F1E11", "F1E12", "F1E13", "F1E14", "F1E15", "F1E16", "F1E17", "F1E18", "F1E19", "F1E20", "F1E21", "F1E22", "F1E23", "F1E24", "F1E25", "F1E26", "F2E0", "F2E1", "F2E2", "F2E3", "F2E4", "F2E5", "F2E6", "F2E7", "F2E8", "F2E9", "F3E0", "F3E1", "F3E2", "F3E3", "F3E4", "F3E5", "F3E6", "F3E7", "F3E8", "F3E9", "F3E10", "F3E11", "F3E12", "F3E13", "F4E0", "F4E1", "F4E2", "F4E3", "F4E4", "F4E5", "F4E6", "F4E7", "F4E8", "F4E9", "F4E10", "F4E11", "F4E12", "F4E13", "F4E14", "F4E15", "F4E16", "F4E17", "F5E0", "F5E1"}
