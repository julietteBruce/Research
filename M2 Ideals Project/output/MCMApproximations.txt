needsPackage "MCMApproximations"

F0E0 =  netList setupRings(2,2)

F0E1 =  netList setupRings(2,2,Characteristic=>5)

F1E0 =  S = ZZ/101[a,b]/ideal(a^3+b^3)

F1E1 =  R = S/ideal(a*b)

F1E2 =  M = R^1/(ideal vars R)^2

F1E3 =  coApproximationSequence M

F2E0 =  R = ZZ/101[a..d]/ideal"a3"

F2E1 =  apply(5, i -> auslanderInvariant ((R^1)/(ideal(vars R))^(i+1)))

F2E2 =  R = ZZ/101[a..d]/ideal"a3,b4"

F2E3 =  apply(6, i -> auslanderInvariant ((R^1)/(ideal(vars R))^(i+1)))

F2E4 =  S = ZZ/101[a,b,c]

F2E5 =  N = matrix{{0,a,0,0,c},

                {0,0,b,c,0},

                {0,0,0,a,0},

                {0,0,0,0,b},

                {0,0,0,0,0}}

F2E6 =  M = N-transpose N

F2E7 =  J = pfaffians(4,M)

F2E8 =  R = S/J

F2E9 =  I = ideal vars R

F2E10 =  scan(5, i->print auslanderInvariant ((R^1)/(I^i)))

F3E0 =  R = ZZ/101[x,y,z]

F3E1 =  M0 = R^1/(ideal(x,y,z)*ideal (x,y));

F3E2 =  M1 = coker random(R^{1,2}, R^{0,-1,-2}); -- dim 1

F3E3 =  M2 = coker random(R^{1,2}, R^{0,-1,-2,-4}); -- dim 0

F4E0 =  S = ZZ/101[a,b,c]

F4E1 =  R = S/ideal(a^3+b^3+c^3)

F4E2 =  M = coker random(R^2, R^{4:-1});

F4E3 =  Ea = approximationSequence M;

F4E4 =  netList apply({1,2,3}, i-> betti res Ea_i)

F4E5 =  Ec = coApproximationSequence M;

F4E6 =  netList apply(5, i-> betti res prune Ec_i)

F5E0 =  needsPackage "CompleteIntersectionResolutions" -- for "evenExtModule"

F5E1 =  R =setupRings(3,2);--codims 0..3, degrees = 2

F5E2 =  MM0 = coker random(R_3^2, R_3^{3: -1});

F5E3 =  (M,kkk,p) = setupModules(R,MM0);

F5E4 =  apply(3, j->regularity evenExtModule M_(j+1))

F6E0 =  setRandomSeed 100

F6E1 =  c = 3

F6E2 =  S = setupRings(c,d);

F6E3 =  R = S_c; -- complete intersection, codim = c

F6E4 =  R' = S_(c-1); --codim c-1

F6E5 =  Mc = coker vars R;

F6E6 =  (M,k,p) = setupModules(S,Mc); --M_(c-1) is Mc as an R_(c-1)-module

F6E7 =  ca = coApproximation M_(c-1);

F6E8 =  M'' = coker ca;

F6E9 =  N = target ca

F6E10 =  profondeur M'' == dim ring M'' -- an MCM module

F6E11 =  M'' == source approximation(M'', Total=>false) -- no free summands

F6E12 =  2 == length res(N, LengthLimit =>10) -- projective dimension <\infty

F7E0 =  S = ZZ/101[a,b]/ideal(a^3+b^3)

F7E1 =  R = S/ideal(a*b)

F7E2 =  M = R^1/(ideal vars R)^2

F7E3 =  approximationSequence M

F8E0 =  R = ZZ/101[a,b]/ideal(a^2)

F8E1 =  k = coker vars R

F8E2 =  approximation k

F8E3 =  M = image vars R

F8E4 =  approximation M

F8E5 =  approximation(M, Total=>false)

F8E6 =  approximation(M, CoDepth => 0)

F9E0 =  R = setupRings(4,3);

F9E1 =  M = coker vars R_2;

F9E2 =  betti res M

F9E3 =  betti syzygyModule(2,M)

F9E4 =  betti (N2 = syzygyModule(-2,M))

F9E5 =  betti res N2

F9E6 =  betti syzygyModule(-2,M,CoDepth=>2)

exampleIDS = {"F0E0", "F0E1", "F1E0", "F1E1", "F1E2", "F1E3", "F2E0", "F2E1", "F2E2", "F2E3", "F2E4", "F2E5", "F2E6", "F2E7", "F2E8", "F2E9", "F2E10", "F3E0", "F3E1", "F3E2", "F3E3", "F4E0", "F4E1", "F4E2", "F4E3", "F4E4", "F4E5", "F4E6", "F5E0", "F5E1", "F5E2", "F5E3", "F5E4", "F6E0", "F6E1", "F6E2", "F6E3", "F6E4", "F6E5", "F6E6", "F6E7", "F6E8", "F6E9", "F6E10", "F6E11", "F6E12", "F7E0", "F7E1", "F7E2", "F7E3", "F8E0", "F8E1", "F8E2", "F8E3", "F8E4", "F8E5", "F8E6", "F9E0", "F9E1", "F9E2", "F9E3", "F9E4", "F9E5", "F9E6"}
