needsPackage "MonomialIntegerPrograms"

F0E0 =  R = QQ[x,y,z,w,v];

F0E1 =  I = monomialIdeal(x*y*w, x*z*v, y*x, y*z*v);

F0E2 =  dimensionIP(I)

F0E3 =  ScipPrintLevel = 0;

F0E4 =  J = monomialIdeal(x*y^3*z^7, y^4*w*v, z^2*v^8, x*w^3*v^3, y^10, z^10)

F0E5 =  dimensionIP(J)

F1E0 =  R = QQ[x,y,z,w,v];

F1E1 =  I = monomialIdeal(x*y*w, x*z*v, y*x, y*z*v);

F1E2 =  codimensionIP(I)

F1E3 =  ScipPrintLevel = 0;

F1E4 =  J = monomialIdeal(x*y^3*z^7, y^4*w*v, z^2*v^8, x*w^3*v^3, y^10, z^10)

F1E5 =  codimensionIP(J)

F2E0 =  R = QQ[x,y,z,w,v];

F2E1 =  I = monomialIdeal(y^12, x*y^3, z*w^3, z*v*y^10, z*x^10, v*z^10, w*v^10, y*v*x*z*w);

F2E2 =  ScipPrintLevel = 0;

F2E3 =  minimalPrimesIP(I, 1)

F2E4 =  minimalPrimesIP I

F2E5 =  minimalPrimes I

F3E0 =  R = QQ[x,y,z]

F3E1 =  M = monomialIdealsWithHilbertFunction(L, R); #M

F3E2 =  netList take(M, 5)

F3E3 =  M = monomialIdealsWithHilbertFunction(L, R, BoundGenerators => 3); #M

F3E4 =  netList take(M, 5)

F3E5 =  S = QQ[a..f]

F3E6 =  I = monomialIdealsWithHilbertFunction({1, 6, 19, 45, 84}, S, SquareFree => true); #I

F3E7 =  first random I

F3E8 =  #monomialIdealsWithHilbertFunction({1, 3, 6, 5, 4, 4}, R, FirstBetti => 5)

F3E9 =  #monomialIdealsWithHilbertFunction({1, 3, 6, 5, 4, 4}, R, FirstBetti => 6)

F3E10 =  #monomialIdealsWithHilbertFunction({1, 3, 4, 2, 1}, R, GradedBettis => {0, 0, 2, 2, 1})

F3E11 =  #monomialIdealsWithHilbertFunction({1, 3, 6, 7, 6, 5, 4, 4, 4}, R, FirstBetti => 6, BoundGenerators => 5)

F3E12 =  #monomialIdealsWithHilbertFunction({1, 3, 6, 7, 6, 5, 4, 4, 4}, R, FirstBetti => 6, BoundGenerators => 4)

F3E13 =  #monomialIdealsWithHilbertFunction({1, 4, 7, 10, 13}, S, SquareFree => true, FirstBetti => 5)

F3E14 =  #monomialIdealsWithHilbertFunction({1, 4, 7, 10, 13}, S, SquareFree => true, BoundGenerators => 3)

F3E15 =  #monomialIdealsWithHilbertFunction({1, 4, 7, 10, 13}, S, SquareFree => true, GradedBettis => {0, 2, 3, 1, 0})

F4E0 =  R = QQ[a,b,c];

F4E1 =  ScipPrintLevel = 1;

F4E2 =  codim(monomialIdeal(a^2, b*a, c*b))

F4E3 =  degree(monomialIdeal(a^2, b*a, c*b))

F4E4 =  loadBuiltinCodimAndDegree();

F4E5 =  codim(monomialIdeal(a^2, b*a, c*b))

F4E6 =  degree(monomialIdeal(a^2, b*a, c*b))

F5E0 =  R = QQ[x,y,z]

F5E1 =  bettiTablesWithHilbertFunction(L, R) --outputs unique tables matching the criteria

F5E2 =  bettiTablesWithHilbertFunction(L, R, Count => true) --tallies distinct ideals giving each table

F5E3 =  bettiTablesWithHilbertFunction(L, R, FirstBetti => 5) --only returns tables whose first total betti number is 5

F5E4 =  bettiTablesWithHilbertFunction(L, R, GradedBettis => {0, 0, 2, 2, 1}) --only returns tables whose first graded betti numbers match a given sequence

F5E5 =  bettiTablesWithHilbertFunction(L, R, BoundGenerators => 3)

F5E6 =  bettiTablesWithHilbertFunction(L, R, BoundGenerators => 3, Count => true)

F5E7 =  S = QQ[a..f]

F5E8 =  bettiTablesWithHilbertFunction({1, 6, 19, 45, 86}, S, SquareFree => true)

F5E9 =  bettiTablesWithHilbertFunction({1, 3, 6, 7, 6, 5, 4, 4, 4}, R, FirstBetti => 6, BoundGenerators => 5, Count => true)

F5E10 =  bettiTablesWithHilbertFunction({1, 4, 7, 10, 13}, S, SquareFree => true, FirstBetti => 5)

F5E11 =  bettiTablesWithHilbertFunction({1, 4, 7, 10, 13}, S, SquareFree => true, GradedBettis => {0, 2, 3, 1, 0})

F6E0 =  R = QQ[x,y,z,w,v];

F6E1 =  I = monomialIdeal(y^12, x*y^3, z*w^3, z*v*y^10, z*x^10, v*z^10, w*v^10, y*v*x*z*w);

F6E2 =  ScipPrintLevel = 0;

F6E3 =  L1 = topMinimalPrimesIP I

F6E4 =  L2 = topMinimalPrimesIP(I, IgnorePrimes=>L1)

F6E5 =  minimalPrimes I

F7E0 =  R = QQ[x,y,z,w,v];

F7E1 =  I = monomialIdeal(x*y*w, x*z*v, y*x, y*z*v);

F7E2 =  degreeIP(I, KnownDim => 3)

F7E3 =  degreeIP(I)

F8E0 =  R = QQ[a,b,c];

F8E1 =  ScipPrintLevel = 1;

F8E2 =  loadBuiltinCodimAndDegree();

F8E3 =  codim(monomialIdeal(a^2, b*a, c*b))

F8E4 =  degree(monomialIdeal(a^2, b*a, c*b))

F8E5 =  loadSCIPCodimAndDegree();

F8E6 =  codim(monomialIdeal(a^2, b*a, c*b))

F8E7 =  degree(monomialIdeal(a^2, b*a, c*b))

F9E0 =  R = QQ[x,y,z,w,v];

F9E1 =  I = monomialIdeal(y^12, x*y^3, z*w^3, z*v*y^10, z*x^10, v*z^10, w*v^10, y*v*x*z*w);

F9E2 =  ScipPrintLevel = 0;

F9E3 =  minimalPrimes(I)

F9E4 =  apply(oo, p -> dim p)

F9E5 =  topMinimalPrimesIP(I)

F10E0 =  loadPackage("MonomialIntegerPrograms", Configuration => {"CustomScipPrintLevel" => "2"}, Reload => true);

exampleIDS = {"F0E0", "F0E1", "F0E2", "F0E3", "F0E4", "F0E5", "F1E0", "F1E1", "F1E2", "F1E3", "F1E4", "F1E5", "F2E0", "F2E1", "F2E2", "F2E3", "F2E4", "F2E5", "F3E0", "F3E1", "F3E2", "F3E3", "F3E4", "F3E5", "F3E6", "F3E7", "F3E8", "F3E9", "F3E10", "F3E11", "F3E12", "F3E13", "F3E14", "F3E15", "F4E0", "F4E1", "F4E2", "F4E3", "F4E4", "F4E5", "F4E6", "F5E0", "F5E1", "F5E2", "F5E3", "F5E4", "F5E5", "F5E6", "F5E7", "F5E8", "F5E9", "F5E10", "F5E11", "F6E0", "F6E1", "F6E2", "F6E3", "F6E4", "F6E5", "F7E0", "F7E1", "F7E2", "F7E3", "F8E0", "F8E1", "F8E2", "F8E3", "F8E4", "F8E5", "F8E6", "F8E7", "F9E0", "F9E1", "F9E2", "F9E3", "F9E4", "F9E5", "F10E0"}
