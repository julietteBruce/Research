needsPackage "PruneComplex"

F0E0 =  R = ZZ/32003[vars(0..17)];

F0E1 =  m1 = genericMatrix(R,a,3,3)

F0E2 =  m2 = genericMatrix(R,j,3,3)

F0E3 =  I = ideal(m1*m2-m2*m1)

F0E4 =  C = res I;

F0E5 =  D = C[-10]

F0E6 =  MC = toMutableComplex D;

F0E7 =  MC = first pruneComplex MC;

F0E8 =  D' = toChainComplex MC

F0E9 =  assert(betti D == betti D'[-10])

F1E0 =  needsPackage "LocalRings";

F1E1 =  R = ZZ/32003[vars(0..5)];

F1E2 =  I = ideal"abc-def,ab2-cd2-c,-b3+acd";

F1E3 =  C = res I;

F1E4 =  M = ideal gens R;

F1E5 =  RM = localRing(R, M);

F1E6 =  F = C.dd_2;

F1E7 =  FM = F ** RM

F1E8 =  f = liftUp FM;

F1E9 =  g = syz f;

F1E10 =  h = syz g;

F1E11 =  C = {g ** RM, h ** RM}/mutableMatrix;

F1E12 =  C = pruneDiff(C, 1, PruningMap => false)

F1E13 =  g' = C#0;

F1E14 =  N = transpose entries FM;

F1E15 =  for i from 0 to numcols FM - 1 do

F1E16 =  GM = map(source FM, , matrix g')

F1E17 =  kernel FM == image GM

F2E0 =  needsPackage "LocalRings"

F2E1 =  R = ZZ/32003[vars(0..3)]

F2E2 =  I = monomialCurveIdeal(R, {1, 3, 4})

F2E3 =  C = res I

F2E4 =  RP = localRing(R, ideal"a,b,c");

F2E5 =  D = (C ++ C[-5]) ** RP

F2E6 =  MD = toMutableComplex D

F2E7 =  pruneComplex MD

F3E0 =  R = ZZ/32003[a..f]

F3E1 =  I = ideal"abc-def,ab2-cd2-c,acd-b3-1"

F3E2 =  S = (coefficientRing R)(monoid [gens R, local h]);

F3E3 =  Ihom = ideal homogenize(sub(gens gb I, S), S_(numgens R));

F3E4 =  Chom = (res(Ihom, FastNonminimal=>true))[-10];

F3E5 =  C = (map(R, S, gens R | {1})) Chom

F3E6 =  D = pruneComplex C

F3E7 =  D.dd

F3E8 =  D1 = pruneComplex(C, PruningMap => false)

F3E9 =  D1.dd

F3E10 =  D2 = pruneComplex(C, Strategy => null, Direction => "both")

F3E11 =  D2.dd

F3E12 =  R = ZZ/32003[vars(0..8)]

F3E13 =  M = genericMatrix(R,3,3)

F3E14 =  I = minors(2, M)

F3E15 =  C = res(I, FastNonminimal=>true)

F3E16 =  pruneComplex(C, UnitTest => isScalar)

F4E0 =  R = ZZ/32003[vars(0..17)];

F4E1 =  m1 = genericMatrix(R,a,3,3)

F4E2 =  m2 = genericMatrix(R,j,3,3)

F4E3 =  I = ideal(m1*m2-m2*m1)

F4E4 =  C = res(I, FastNonminimal=>true)

F4E5 =  D = pruneComplex(C, UnitTest => isScalar)

F4E6 =  isCommutative D.cache.pruningMap

F4E7 =  betti D == betti res I

exampleIDS = {"F0E0", "F0E1", "F0E2", "F0E3", "F0E4", "F0E5", "F0E6", "F0E7", "F0E8", "F0E9", "F1E0", "F1E1", "F1E2", "F1E3", "F1E4", "F1E5", "F1E6", "F1E7", "F1E8", "F1E9", "F1E10", "F1E11", "F1E12", "F1E13", "F1E14", "F1E15", "F1E16", "F1E17", "F2E0", "F2E1", "F2E2", "F2E3", "F2E4", "F2E5", "F2E6", "F2E7", "F3E0", "F3E1", "F3E2", "F3E3", "F3E4", "F3E5", "F3E6", "F3E7", "F3E8", "F3E9", "F3E10", "F3E11", "F3E12", "F3E13", "F3E14", "F3E15", "F3E16", "F4E0", "F4E1", "F4E2", "F4E3", "F4E4", "F4E5", "F4E6", "F4E7"}
