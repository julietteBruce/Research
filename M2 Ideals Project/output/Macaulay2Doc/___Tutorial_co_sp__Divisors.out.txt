needsPackage "Macaulay2Doc"

F625E0 =  KK = ZZ/31991

F625E1 =  SE = KK[x,y,z]/(y^2*z - x*(x-z)*(x+3*z))

F625E2 =  purify1S2 = I -> (

         -- Assuming ring I is S2, and I is not 0, returns the 

         -- pure codimension 1 part of I.

         -- Find a nonzero element of I:

         M := compress gens I;

         -- Explanation: gens I is 

         -- the matrix of generators of I; compress

         -- removes the entries that are 0

         -- and := makes M a local variable.

         if numgens source M == 0 

         then error "purify1S2: expected nonzero ideal";

         f := ideal M_(0,0);

         -- f is the ideal generated by the first entry.

         -- Since ring I is S2, the ideal f is 

         -- pure codimension 1.  Thus

         f:(f:I)

         -- is the pure codimension 1 part. (The last 

         -- expression given in a function is the returned

         -- value, provided the semicolon is left off.)

         )

F625E3 =  R = ZZ/5[a,b]

F625E4 =  purify1S2 ideal(a^2,a*b)

F625E5 =  Divisor = new Type of BasicList

F625E6 =  divisor = method()

F625E7 =  divisor(Ideal,Ideal) := (I,J) -> new Divisor from {purify1S2 I,purify1S2 J};

F625E8 =  divisor Ideal := I -> divisor(I, ideal 1_(ring I));

F625E9 =  P = divisor ideal(x,z)

F625E10 =  R = divisor ideal(x,y)

F625E11 =  R1 = divisor ideal(x-z,y)

F625E12 =  R2 = divisor ideal(x+3*z,y)

F625E13 =  Q1 = divisor ideal(y-6*z, x-3*z)

F625E14 =  normalForm = method()

F625E15 =  normalForm Divisor := D -> new Divisor from {D#0 : D#1, D#1 : D#0};

F625E16 =  Divisor == Divisor := (D,E) -> toList normalForm D == toList normalForm E;

F625E17 =  D = divisor(ideal(y, x^2+2*x*z-3*z^2), ideal(x-z, y))

F625E18 =  normalForm D

F625E19 =  D == R2

F625E20 =  Divisor + Divisor := (D,E) -> divisor(D#0 * E#0, D#1 * E#1);

F625E21 =  - Divisor := (D) -> new Divisor from {D#1, D#0};

F625E22 =  Divisor - Divisor := (D,E) -> D + (-E);

F625E23 =  ZZ Divisor := ZZ * Divisor := (n,D) -> divisor((D#0)^n, (D#1)^n);

F625E24 =  2 P

F625E25 =  3 P

F625E26 =  D = P-R1

F625E27 =  D2 = 2 P - 2 R1

F625E28 =  D = 2 P

F625E29 =  I = D#0

F625E30 =  J = D#1

F625E31 =  f = z

F625E32 =  LD = basis(degree f, purify1S2((f*J) : I))

F625E33 =  LD = super (LD ** (ring target LD))

F625E34 =  imI = purify1S2(((z+x)*I) : z)

F625E35 =  degree imI

F625E36 =  globalSections = method()

F625E37 =  globalSections Divisor := (D) -> (

          -- First let's grab the parts (I,J) of D.

          I := D#0;

          J := D#1;

          -- Let 'f' be the first element of the 

          -- matrix of generators of the ideal I.

          f := (gens I)_(0,0);

          -- Now compute the basis of global sections

          -- just as above

          LD := basis(degree f, purify1S2((f*J) : I));

          LD = super (LD ** (ring target LD));

          -- Return both this vector space and the denominator

          {LD, f});

F625E38 =  sectionIdeal = (f,g,D) -> (

          I := D#0;

          J := D#1;

          purify1S2((f*I):g) : J

          );

F625E39 =  D = 4 P

F625E40 =  L = globalSections D

F625E41 =  phi = map(SE, ZZ/31991[a..d], L#0)

F625E42 =  ker phi

F625E43 =  D = 4 P - R

F625E44 =  L = globalSections D

F625E45 =  II = sectionIdeal(y*z+x*z+x^2, z^2, D)

F625E46 =  degree II

F625E47 =  globalSections (P-R)

F625E48 =  D = 2 P - 2 R

F625E49 =  LB = globalSections D

F625E50 =  linearlyEquivalent = (D,E) -> (

          F := normalForm(D-E);

          LB := globalSections F;

          L := LB#0;

          -- L is the matrix of numerators. Thus numgens source L

          -- is the dimension of the space of global sections.

          if numgens source L != 1 

          then false

          else (

              R := ring L;

              V := sectionIdeal(L_(0,0), LB#1, F);

              if V == ideal(1_R) 

                then L_(0,0)/LB#1

                else false)

          );

F625E51 =  linearlyEquivalent(P,R)

F625E52 =  linearlyEquivalent(2 P, 2 R)

F625E53 =  effective = (D) -> (

          LB := globalSections D;

          L := LB#0;  -- the matrix of numerators

          if numgens source L == 0 

          then error(toString D + " is not effective")

          else divisor sectionIdeal(L_(0,0), LB#1, D));

F625E54 =  effective(2 R - P)

F625E55 =  addition = (R,S) -> effective(R + S - P);

F625E56 =  addition(R1,R2)

F625E57 =  Q2 = addition(Q1, Q1)

F625E58 =  Q3 = addition(Q2, Q1)

F625E59 =  Q4 = addition(Q3, Q1)

F625E60 =  Q4a = addition(Q2,Q2)

F625E61 =  S = ZZ/31991[a,b,c,d];

F625E62 =  catalect = map(S^2, 3, (i,j)->S_(i+j))

F625E63 =  IC = minors(2, catalect)

F625E64 =  SX = S/IC

F625E65 =  KX = Ext^2(coker gens IC,S^{-4})

F625E66 =  canpres = substitute(presentation(KX), SX)

F625E67 =  betti canpres

F625E68 =  I1 = transpose (syz transpose canpres)_{0}

F625E69 =  dg = (degrees (target I1))_0_0

F625E70 =  divisorFromModule = M -> (

        -- given a module M, returns the divisor of the image

        -- of a nonzero homomorphism to R, suitably twisted.

        -- first get the presentation of M

          I1 := transpose (syz transpose presentation M)_{0};

        -- The degree is

          d := (degrees target I1)_0_0;

        -- We need to balance the degree d with a power

        -- of the first nonzero generator of the ring.

          var1 := (compress vars ring M)_{0};

        -- Now fix up the degrees.

          if d==0 then divisor ideal I1

          else if d>0 then divisor(

                        ideal (I1**dual(target I1)),

                        ideal var1^d

                       )                          

          else divisor ideal( 

                     var1^(-d)**I1**dual target I1

                     )

      );

F625E71 =  M = coker canpres

F625E72 =  divisorFromModule M

F625E73 =  use SX

F625E74 =  divisorFromModule image matrix{{d^2}}

F625E75 =  divisorFromModule SX^{1}

F625E76 =  canonicalDivisor= SX ->(

        -- Given a ring SX, computes a canonical divisor for SX

        I := ideal presentation SX;

        S := ring I;

        embcodim := codim I;

        M := Ext^embcodim(coker gens I,S^{-numgens S});

        M = coker substitute(presentation M, SX);

        divisorFromModule M

        );

F625E77 =  canonicalDivisor SX

exampleIDS = {"F625E0", "F625E1", "F625E2", "F625E3", "F625E4", "F625E5", "F625E6", "F625E7", "F625E8", "F625E9", "F625E10", "F625E11", "F625E12", "F625E13", "F625E14", "F625E15", "F625E16", "F625E17", "F625E18", "F625E19", "F625E20", "F625E21", "F625E22", "F625E23", "F625E24", "F625E25", "F625E26", "F625E27", "F625E28", "F625E29", "F625E30", "F625E31", "F625E32", "F625E33", "F625E34", "F625E35", "F625E36", "F625E37", "F625E38", "F625E39", "F625E40", "F625E41", "F625E42", "F625E43", "F625E44", "F625E45", "F625E46", "F625E47", "F625E48", "F625E49", "F625E50", "F625E51", "F625E52", "F625E53", "F625E54", "F625E55", "F625E56", "F625E57", "F625E58", "F625E59", "F625E60", "F625E61", "F625E62", "F625E63", "F625E64", "F625E65", "F625E66", "F625E67", "F625E68", "F625E69", "F625E70", "F625E71", "F625E72", "F625E73", "F625E74", "F625E75", "F625E76", "F625E77"}
