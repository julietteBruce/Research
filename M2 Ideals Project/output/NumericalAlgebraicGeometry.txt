needsPackage "NumericalAlgebraicGeometry"

F0E0 =  T = randomSd {2,3}

F0E1 =  (S,solsS) = goodInitialPair T;

F0E2 =  M = track(S,T,solsS,gamma=>0.6+0.8*ii,Software=>M2)

F1E0 =  R = CC[u1,u2,u3,x,y]

F1E1 =  f1 = u1*(y-1)+u2*(y-2)+u3*(y-3)

F1E2 =  f2 = (x-11)*(x-12)*(x-13)

F1E3 =  try parameterHomotopy({f1,f2},{u1,u2,u3},{{1,0,0},{0,1+2*ii,0}}, Software=>BERTINI) else "need to install Bertini to run these lines"

F2E0 =  R = CC[x,y]

F2E1 =  I = ideal((x^2+y^2+2)*x,(x^2+y^2+2)*y);

F2E2 =  e = 0.0000001

F2E3 =  W = witnessSet(ideal I_0 , ideal(x-y), {point {{ (1-e)*ii,(1-e)*ii}},point {{ -(1+e)*ii,-(1+e)*ii}}})	

F2E4 =  isOn(point {{sqrt 5*ii,sqrt 3}},W)

F3E0 =  getDefault Predictor

F3E1 =  setDefault(Predictor=>Euler, CorrectorTolerance=>1e-10)

F3E2 =  getDefault Predictor  

F4E0 =  CC[x,y]

F4E1 =  T = {(x-2)^3,y-x+x^2-x^3}

F4E2 =  sols = solveSystem(T,PostProcess=>false);

F4E3 =  p0 = first sols;

F4E4 =  peek p0

F4E5 =  t'end = 1

F4E6 =  p = endGameCauchy(p0.cache#"H",t'end,p0)

F5E0 =  R = CC[x,y]

F5E1 =  F = {x^2+y^2-1, x*y};

F5E2 =  regeneration F 

F5E3 =  R = CC[x,y,z]

F5E4 =  sph = (x^2+y^2+z^2-1); 

F5E5 =  regeneration {sph*(x-1)*(y-x^2), sph*(y-2)*(z-x^3)}

F6E0 =  R = CC[x,y]

F6E1 =  F = {x^2+y^2-1, x*y};

F6E2 =  W = first components regeneration F 

F6E3 =  decompose W

F6E4 =  R = CC[x,y,z]

F6E5 =  sph = (x^2+y^2+z^2-1); 

F6E6 =  decompose \ components regeneration {sph*(x-1)*(y-x^2), sph*(y-2)*(z-x^3)}

F7E0 =  X = inputGate symbol X

F7E1 =  Y = inputGate symbol Y

F7E2 =  T = inputGate symbol T

F7E3 =  F = {X*X-1, Y*Y*Y-1}

F7E4 =  G = {X*X+Y*Y-1, X*X*X+Y*Y*Y-1}

F7E5 =  H = (1 - T) * F + T * G

F7E6 =  HS = gateHomotopy(transpose matrix {H},matrix{{X,Y}},T)

F8E0 =  R = CC[x,y];

F8E1 =  S = {x^2-1,y^2-1};

F8E2 =  T = {x^2+y^2-1, x+y};

F8E3 =  NAGtrace 1

F8E4 =  track(S,T,{(1,1),(1,-1),(-1,1),(-1,-1)})

F9E0 =  T = randomSd {2,3};

F9E1 =  (S,solsS) = goodInitialPair T

F9E2 =  M = track(S,T,solsS,gamma=>0.6+0.8*ii,Software=>M2)

F10E0 =  variables = declareVariable \ {x,y}

F10E1 =  F = gateSystem(matrix{variables}, matrix{{x*y-1},{x^3+y^2-2}})

F10E2 =  evaluate(F,point{{0.1,0.2+ii}})

F10E3 =  evaluate(F,point{{1/2,1/3}})

F10E4 =  evaluate(F,point{{2_(ZZ/101),3}})

F10E5 =  params = declareVariable \ {a,b}

F10E6 =  Fab = gateSystem(matrix{params}, matrix{variables}, matrix{{a*x*y-1},{x^3+y^2-b}})

F10E7 =  evaluate(Fab,point{{1,2}},point{{0.1,0.2+ii}})

F11E0 =  R = CC[x];

F11E1 =  F = polySystem {x^2-2};

F11E2 =  P := refine(F, point{{1.5+0.001*ii}}, Bits=>1000)

F11E3 =  first coordinates P

F11E4 =  R = CC[x,y];

F11E5 =  T = {x^2+y^2-1, x*y};

F11E6 =  sols = { {1.1,-0.1}, {0.1,1.2} };

F11E7 =  refine(T, sols, Software=>M2, ErrorTolerance=>.001, Iterations=>10)

F11E8 =  R = CC[x,y];

F11E9 =  S = {x^2-1,y^2-1};

F11E10 =  T = {x^2+y^2-1, (x-y)^2};

F11E11 =  solsS = {(1,1),(-1,-1)};

F11E12 =  solsT = track(S,T,solsS)

F11E13 =  solsT / coordinates

F11E14 =  refSols = refine(T, solsT)

F11E15 =  refSols / status

F11E16 =  R = CC[x];

F11E17 =  F = polySystem {x^2-2};

F11E18 =  Q := refine(F, point{{1.5+0.001*ii}}, Bits=>1000, Iterations=>2)

F11E19 =  peek Q

F12E0 =  R = CC[x,y,z];

F12E1 =  S = {x^2-z^2,y^2-z^2};

F12E2 =  T = {x^2+y^2-z^2, x*y};

F12E3 =  solsS = {(1,-1,1),(1,1,1)};

F12E4 =  track(S,T,solsS,Predictor=>Certified,Normalize=>true)

F13E0 =  R = CC[x,y];

F13E1 =  F = {x^2+y^2-1, x*y};

F13E2 =  solveSystem F 

F13E3 =  R = CC[x,y];

F13E4 =  F = {x^2+y^2-1, x*y, x*(y+1)};

F13E5 =  solveSystem F 

F14E0 =  CC[x,y,z]

F14E1 =  F = polySystem {x^3,y^3,x^2*y,z^2}

F14E2 =  P0 = point matrix{{0.000001, 0.000001*ii,0.000001-0.000001*ii}}

F14E3 =  isFullNumericalRank evaluate(jacobian F,P0)

F14E4 =  r1 = deflate (F,P0)

F14E5 =  P1' = liftPointToDeflation(P0,F,r1) 

F14E6 =  F1 = F.Deflation#r1

F14E7 =  P1 = newton(F1,P1')

F14E8 =  isFullNumericalRank evaluate(jacobian F1,P1)

F14E9 =  r2 = deflate (F1,P1)

F14E10 =  P2' = liftPointToDeflation(P1,F1,r2) 

F14E11 =  F2 = F1.Deflation#r2

F14E12 =  P2 = newton(F2,P2')

F14E13 =  isFullNumericalRank evaluate(jacobian F2,P2)

F14E14 =  P = point {take(coordinates P2, F.NumberOfVariables)}

F14E15 =  assert(residual(F,P) < 1e-50)	

F15E0 =  R = CC[x,y,z];

F15E1 =  T = {x^2+y^2-1, x*y^2, x^5+y*z+3};

F15E2 =  totalDegreeStartSystem T

F16E0 =  R = CC[x,y,z]

F16E1 =  sph = (x^2+y^2+z^2-1); 

F16E2 =  I = ideal {sph*(y-x^2), sph*(z-x^3)};

F16E3 =  numericalIrreducibleDecomposition I 

F17E0 =  CC[x,y]; F = polySystem {x^2+y^2,x^3+y^3,x^4+y^4}

F17E1 =  G := squareUp F

F17E2 =  peek F

F18E0 =  T = randomSd {2,3};

F18E1 =  (S,solsS) = randomInitialPair T

F18E2 =  M = track(S,T,solsS,gamma=>0.6+0.8*ii,Software=>M2)

F19E0 =  R = QQ[x,y]

F19E1 =  T = {random(3,R)-1, random(2,R)-2}

F19E2 =  (S,solsS) = totalDegreeStartSystem T

F19E3 =  H = segmentHomotopy(S,T,gamma=>1+ii)

F19E4 =  evaluateH(H,transpose matrix first solsS,0)

F20E0 =  R = CC[x,y,z];

F20E1 =  F = {x^2+y^2+z^2-1, y-x^2, z-x^3};

F20E2 =  s = solveSystem F 

F20E3 =  realPoints s

F20E4 =  R = CC[x,y,z];

F20E5 =  sph = x^2+y^2+z^2-1; 

F20E6 =  I = ideal {x*sph*(y-x^2), sph*(z-x^3)};

F20E7 =  numericalIrreducibleDecomposition I 

F21E0 =  R = CC[x,y];

F21E1 =  S = {x^2-1,y^2-1};

F21E2 =  T = {x^2+y^2-1, x*y};

F21E3 =  solsS = {(1,-1),(1,1),(-1,1),(-1,-1)};

F21E4 =  track(S,T,solsS)  

F21E5 =  R = CC[x,y];

F21E6 =  S = {x^2-1,y^2-1};

F21E7 =  T = {x^2+y^2-1, x-y};

F21E8 =  solsS = {(1,-1),(1,1),(-1,1),(-1,-1)};

F21E9 =  track(S,T,solsS,gamma=>0.6+0.8*ii) 

F21E10 =  R = CC[x,y];

F21E11 =  S = {x^2-1,y^2-1};

F21E12 =  T = {x^2+y^2-1, (x-y)^2};

F21E13 =  solsS = {(1,-1),(1,1),(-1,1),(-1,-1)};

F21E14 =  track(S,T,solsS)

F21E15 =  R = CC[x,y,z];

F21E16 =  S = {x^2-z^2,y^2-z^2};

F21E17 =  T = {x^2+y^2-z^2, x*y};

F21E18 =  solsS = {(1,-1,1),(1,1,1),(-1,1,1),(-1,-1,1)};

F21E19 =  track(S,T,solsS,Predictor=>Certified,Normalize=>true)

F22E0 =  R = CC[x,y,z]

F22E1 =  W = witnessSet(ideal {x^2+y^2+z^2-1, z^2}, matrix "1,0,0,0", {{{0,1,0_CC}},{{0,-1,0_CC}}}/point ) 

F22E2 =  P := sample(W, Tolerance=>1e-15)   

F22E3 =  isOn(P,W)

exampleIDS = {"F0E0", "F0E1", "F0E2", "F1E0", "F1E1", "F1E2", "F1E3", "F2E0", "F2E1", "F2E2", "F2E3", "F2E4", "F3E0", "F3E1", "F3E2", "F4E0", "F4E1", "F4E2", "F4E3", "F4E4", "F4E5", "F4E6", "F5E0", "F5E1", "F5E2", "F5E3", "F5E4", "F5E5", "F6E0", "F6E1", "F6E2", "F6E3", "F6E4", "F6E5", "F6E6", "F7E0", "F7E1", "F7E2", "F7E3", "F7E4", "F7E5", "F7E6", "F8E0", "F8E1", "F8E2", "F8E3", "F8E4", "F9E0", "F9E1", "F9E2", "F10E0", "F10E1", "F10E2", "F10E3", "F10E4", "F10E5", "F10E6", "F10E7", "F11E0", "F11E1", "F11E2", "F11E3", "F11E4", "F11E5", "F11E6", "F11E7", "F11E8", "F11E9", "F11E10", "F11E11", "F11E12", "F11E13", "F11E14", "F11E15", "F11E16", "F11E17", "F11E18", "F11E19", "F12E0", "F12E1", "F12E2", "F12E3", "F12E4", "F13E0", "F13E1", "F13E2", "F13E3", "F13E4", "F13E5", "F14E0", "F14E1", "F14E2", "F14E3", "F14E4", "F14E5", "F14E6", "F14E7", "F14E8", "F14E9", "F14E10", "F14E11", "F14E12", "F14E13", "F14E14", "F14E15", "F15E0", "F15E1", "F15E2", "F16E0", "F16E1", "F16E2", "F16E3", "F17E0", "F17E1", "F17E2", "F18E0", "F18E1", "F18E2", "F19E0", "F19E1", "F19E2", "F19E3", "F19E4", "F20E0", "F20E1", "F20E2", "F20E3", "F20E4", "F20E5", "F20E6", "F20E7", "F21E0", "F21E1", "F21E2", "F21E3", "F21E4", "F21E5", "F21E6", "F21E7", "F21E8", "F21E9", "F21E10", "F21E11", "F21E12", "F21E13", "F21E14", "F21E15", "F21E16", "F21E17", "F21E18", "F21E19", "F22E0", "F22E1", "F22E2", "F22E3"}
