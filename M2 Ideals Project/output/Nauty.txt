needsPackage "Nauty"

F0E0 =  R = QQ[a..e];

F0E1 =  graphComplement cycle R

F0E2 =  graphComplement "Dhc"

F0E3 =  G = generateBipartiteGraphs 7;

F0E4 =  time graphComplement G;

F0E5 =  time (graphComplement \ G);

F1E0 =  R = QQ[a..e];

F1E1 =  G = graph {a*e, e*c, c*b, b*d, d*a};

F1E2 =  relabelGraph G

F2E0 =  R = QQ[a..f];

F2E1 =  L = {graph {a*b}, graph {a*b, b*c}, graph {a*b, b*c, c*d}, graph {a*b, b*c, c*d, d*e}};

F2E2 =  s = buildGraphFilter {"NumEdges" => 3};

F2E3 =  filterGraphs(L, s)

F2E4 =  s = buildGraphFilter {"NumEdges" => (2,3)};

F2E5 =  filterGraphs(L, s)

F2E6 =  s = buildGraphFilter {"NumEdges" => (,3)};

F2E7 =  filterGraphs(L, s)

F2E8 =  s = buildGraphFilter {"NumEdges" => (2,)};

F2E9 =  filterGraphs(L, s)

F2E10 =  s = buildGraphFilter {"NumEdges" => (2,), "NegateNumEdges" => true};

F2E11 =  filterGraphs(L, s)

F3E0 =  R = QQ[a..e];

F3E1 =  G = graph {{a, c}, {c, e}, {e, b}, {b, d}, {d, a}};

F3E2 =  areIsomorphic(cycle R, G)

F3E3 =  L = apply(permutations gens R, P -> graphToString graph apply(5, i-> {P_i, P_((i+1)%5)}));

F3E4 =  N = removeIsomorphs L

F3E5 =  stringToGraph(first N, R)

F4E0 =  sparse6ToGraph6 ":DaY_~"

F4E1 =  sparse6ToGraph6 ":M"

F5E0 =  R = QQ[a..e];

F5E1 =  stringToGraph("Dhc", R)

F6E0 =  A000088 = apply(1..9, n -> #generateGraphs n)

F6E1 =  B = apply(1..12, n -> generateGraphs(n, OnlyBipartite => true));

F6E2 =  forestsOnly = buildGraphFilter {"NumCycles" => 0};

F6E3 =  A005195 = apply(B, graphs -> #filterGraphs(graphs, forestsOnly))

F6E4 =  treesOnly = buildGraphFilter {"NumCycles" => 0, "Connectivity" => 0, "NegateConnectivity" => true};

F6E5 =  A000055 = apply(B, graphs -> #filterGraphs(graphs, treesOnly))

F6E6 =  connected = buildGraphFilter {"Connectivity" => 0, "NegateConnectivity" => true};

F6E7 =  prob = n -> log(n)/n;

F6E8 =  apply(2..30, n -> #filterGraphs(generateRandomGraphs(n, 100, 2*(prob n)), connected))

F6E9 =  apply(2..30, n -> #filterGraphs(generateRandomGraphs(n, 100, (prob n)/2), connected))

F7E0 =  R = QQ[a..e];

F7E1 =  isPlanar cycle R

F7E2 =  isPlanar completeGraph R

F8E0 =  R = QQ[a..e];

F8E1 =  generateBipartiteGraphs(R, 2)

F9E0 =  R = QQ[a..d];

F9E1 =  G = graph {a*b, c*d};

F9E2 =  S = QQ[a..f];

F9E3 =  newEdges(G, S)

F10E0 =  R = QQ[a..e];

F10E1 =  addEdges cycle R

F11E0 =  R = QQ[a..e];

F11E1 =  removeEdges cycle R

F11E2 =  removeEdges graph {a*b, a*c, b*c, c*d, d*e}

F12E0 =  R = QQ[a..e];

F12E1 =  stringToEdgeIdeal("Dhc", R)

F13E0 =  generateRandomGraphs(5, 5, RandomSeed => 314159)

F13E1 =  generateRandomGraphs(5, 5)

F13E2 =  generateRandomGraphs(5, 5, RandomSeed => 314159)

F14E0 =  R = QQ[a..e];

F14E1 =  generateGraphs(R, 4, 6, OnlyConnected => true)

F15E0 =  L = generateGraphs 5;

F15E1 =  filterGraphs(L, {"Connectivity" => 0, "NegateConnectivity" => true})

F16E0 =  R = QQ[a..f];

F16E1 =  G = {"EhEG", cycle R, completeGraph R, graph {a*d, d*b, b*e, e*c, c*f, f*a}};

F16E2 =  removeIsomorphs G

F17E0 =  R = QQ[a..e];

F17E1 =  generateRandomRegularGraphs(R, 3, 2)

F18E0 =  graph6ToSparse6 "Dhc"

F18E1 =  graph6ToSparse6 "M????????????????"

F19E0 =  L = generateGraphs 5;

F19E1 =  countGraphs(L, {"Connectivity" => 0, "NegateConnectivity" => true})

F20E0 =  R = QQ[a..e];

F20E1 =  areIsomorphic(cycle R, graph {a*c, c*e, e*b, b*d, d*a})

F20E2 =  areIsomorphic(cycle R, completeGraph R)

F20E3 =  cycle R == "Dhc"

F21E0 =  R = QQ[a..e];

F21E1 =  K5 = completeGraph R;

F21E2 =  P = onlyPlanar(generateGraphs 5, true)

F21E3 =  areIsomorphic(first P, K5)

F22E0 =  graphToString({{0,1}, {1,2}, {2,3}, {3,4}, {0,4}}, 5)

F22E1 =  R = QQ[a..e];

F22E2 =  graphToString monomialIdeal (a*c, a*d, b*d, b*e, c*e)

F22E3 =  graphToString cycle R

F22E4 =  graphToString "Dhc"

F23E0 =  R = QQ[a..f];

F23E1 =  G = graph flatten apply({a,c,e}, v->v*{b,d,f})

F23E2 =  relabelBipartite G

F24E0 =  R = QQ[a..z];

F24E1 =  g6 = graphToString cycle R; #g6

F24E2 =  s6 = graph6ToSparse6 g6; #s6

F24E3 =  g6 = graphToString completeGraph R; #g6

F24E4 =  s6 = graph6ToSparse6 g6; #s6

F25E0 =  R = QQ[a..e];

F25E1 =  neighborhoodComplements graph {a*b, a*c, b*c, c*d, d*e}

exampleIDS = {"F0E0", "F0E1", "F0E2", "F0E3", "F0E4", "F0E5", "F1E0", "F1E1", "F1E2", "F2E0", "F2E1", "F2E2", "F2E3", "F2E4", "F2E5", "F2E6", "F2E7", "F2E8", "F2E9", "F2E10", "F2E11", "F3E0", "F3E1", "F3E2", "F3E3", "F3E4", "F3E5", "F4E0", "F4E1", "F5E0", "F5E1", "F6E0", "F6E1", "F6E2", "F6E3", "F6E4", "F6E5", "F6E6", "F6E7", "F6E8", "F6E9", "F7E0", "F7E1", "F7E2", "F8E0", "F8E1", "F9E0", "F9E1", "F9E2", "F9E3", "F10E0", "F10E1", "F11E0", "F11E1", "F11E2", "F12E0", "F12E1", "F13E0", "F13E1", "F13E2", "F14E0", "F14E1", "F15E0", "F15E1", "F16E0", "F16E1", "F16E2", "F17E0", "F17E1", "F18E0", "F18E1", "F19E0", "F19E1", "F20E0", "F20E1", "F20E2", "F20E3", "F21E0", "F21E1", "F21E2", "F21E3", "F22E0", "F22E1", "F22E2", "F22E3", "F22E4", "F23E0", "F23E1", "F23E2", "F24E0", "F24E1", "F24E2", "F24E3", "F24E4", "F25E0", "F25E1"}
