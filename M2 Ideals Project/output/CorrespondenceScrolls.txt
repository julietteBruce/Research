needsPackage "CorrespondenceScrolls"

F0E0 =  L = {3,4}

F0E1 =  S = productOfProjectiveSpaces(#L) --creates the multi-graded ring of (P^1)^(#L)

F0E2 =  Delta = smallDiagonal S -- the ideal of the small diagonal of (P^1)^(#L)

F0E3 =  G = correspondenceScroll(Delta, L)

F0E4 =  minimalBetti G

F0E5 =  G = correspondenceScroll(Delta^2, L)

F0E6 =  minimalBetti G

F0E7 =  T = ZZ/32003[y_0,y_1,y_2]

F0E8 =  threepoints = gens intersect(ideal(y_0,y_1),ideal(y_0,y_2),ideal(y_1,y_2))

F0E9 =  f = threepoints*random(source threepoints, T^{-3}); -- general cubic through the three points

F0E10 =  L = {2,2,2}

F0E11 =  x = symbol x;

F0E12 =  S = productOfProjectiveSpaces(#L,VariableName =>"x") --creates the multi-graded ring of (P^1)^(#L)

F0E13 =  ST = (flattenRing(T**S))_0

F0E14 =  irrel = irrelevantIdeal ST;

F0E15 =  ff =  {{y_0,y_1},{y_0,y_2},{y_1,y_2}} -- projections from the three points

F0E16 =  ff =  apply(ff, f-> apply(f, p-> sub(p, ST)))

F0E17 =  D1 = det matrix{{x_(0,0),ff_0_1},{x_(0,1),ff_0_0}}

F0E18 =  D2 = det matrix{{x_(1,0),ff_1_1},{x_(1,1),ff_1_0}}

F0E19 =  D3 = det matrix{{x_(2,0),ff_2_1},{x_(2,1),ff_2_1}}

F0E20 =  J = sub(ideal f, ST)+ideal(D1,D2,D3)

F0E21 =  Js = saturate(J, irrel);

F0E22 =  I = eliminate({y_0,y_1,y_2}, Js);

F0E23 =  IS = (map(S,ST))I;

F0E24 =  codim I

F0E25 =  g = correspondenceScroll(IS, L);

F0E26 =  minimalBetti g

F1E0 =  R = productOfProjectiveSpaces 3

F1E1 =  vars R

F1E2 =  (gens R)/degree

F1E3 =  irrelevantIdeal R

F2E0 =  betti res carpet{1,3}

F3E0 =  P = productOfProjectiveSpaces {1,1}

F3E1 =  Delta = smallDiagonal P

F3E2 =  M = P^1/(Delta^2)

F3E3 =  correspondencePolynomial (M,{1,1})

F3E4 =  correspondencePolynomial (M,{2,2})

F4E0 =  p = 2

F4E1 =  S = ZZ/101[x_0..x_(p+q-2)]

F4E2 =  hankelMatrix(vars S, p,q)

F4E3 =  r = vars S ** transpose vars S

F4E4 =  hankelMatrix(r, p,q)

F4E5 =  hankelMatrix(S,p,q)

F4E6 =  hankelMatrix(r, p,q+2)

F4E7 =  hankelMatrix(p,q+2)

F5E0 =  S = ZZ/101[a,b]

F5E1 =  I = ideal 0_S

F5E2 =  f0 = matrix"a,b"

F5E3 =  f1 = matrix"a,b"

F5E4 =  maps = {f0,f1}

F5E5 =  schemeInProduct(I, maps,VariableName =>"Y")

F6E0 =  P = productOfProjectiveSpaces{1,2}

F6E1 =  M1 = P^1

F6E2 =  multiHilbertPolynomial M1

F7E0 =  smallDiagonal 3

F7E1 =  S = productOfProjectiveSpaces 3

F7E2 =  smallDiagonal S

F8E0 =  R = productOfProjectiveSpaces{1,3}

F8E1 =  v = gens R

F8E2 =  v/degree

F8E3 =  gens productOfProjectiveSpaces({1,1}, VariableName => "y")

F8E4 =  gens productOfProjectiveSpaces 2

exampleIDS = {"F0E0", "F0E1", "F0E2", "F0E3", "F0E4", "F0E5", "F0E6", "F0E7", "F0E8", "F0E9", "F0E10", "F0E11", "F0E12", "F0E13", "F0E14", "F0E15", "F0E16", "F0E17", "F0E18", "F0E19", "F0E20", "F0E21", "F0E22", "F0E23", "F0E24", "F0E25", "F0E26", "F1E0", "F1E1", "F1E2", "F1E3", "F2E0", "F3E0", "F3E1", "F3E2", "F3E3", "F3E4", "F4E0", "F4E1", "F4E2", "F4E3", "F4E4", "F4E5", "F4E6", "F4E7", "F5E0", "F5E1", "F5E2", "F5E3", "F5E4", "F5E5", "F6E0", "F6E1", "F6E2", "F7E0", "F7E1", "F7E2", "F8E0", "F8E1", "F8E2", "F8E3", "F8E4"}
