<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>deformMCMModule(Module) -- deformation in the absolute case</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <link type="text/css" rel="stylesheet" href="../../../../Macaulay2/Style/doc.css"/>

    <link rel="stylesheet" href="../../../../Macaulay2/Style/katex/katex.min.css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/katex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/auto-render.min.js"></script>
    <script defer="defer" type="text/javascript">
      var macros = {
          "\\break": "\\\\",
          "\\ZZ": "\\mathbb{Z}",
          "\\NN": "\\mathbb{N}",
          "\\QQ": "\\mathbb{Q}",
          "\\RR": "\\mathbb{R}",
          "\\CC": "\\mathbb{C}",
          "\\PP": "\\mathbb{P}"
      }, delimiters = [
          { left: "$$",  right: "$$",  display: true},
          { left: "\\[", right: "\\]", display: true},
          { left: "$",   right: "$",   display: false},
          { left: "\\(", right: "\\)", display: false}
      ], ignoredTags = ["tt", "script", "noscript", "style", "textarea", "pre", "code", "option"];
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, { delimiters: delimiters, macros: macros, ignoredTags: ignoredTags, trust: true });
      });
    </script>
    <style type="text/css">.katex { font-size: 1em; }</style>
    <link href="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.css" rel="stylesheet" type="text/css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/render-a11y-string.min.js"></script>
    <script type="text/javascript" src="../../../../Macaulay2/Style/highlight.js"></script>
  </head>
  <body>
    <table class="buttons">
      <tr>
<td>          <div>
<a href="_deform__M__C__M__Module_lp__Module_cm__Ring__Map_rp.html">next</a> | <a href="_deform__M__C__M__Module_lp..._cm__Degree__Limit_eq_gt..._rp.html">previous</a> | <a href="_deform__M__C__M__Module_lp__Module_cm__Ring__Map_rp.html">forward</a> | <a href="_deform__M__C__M__Module_lp..._cm__Degree__Limit_eq_gt..._rp.html">backward</a> | up | <a href="index.html">top</a> | <a href="master.html">index</a> | <a href="toc.html">toc</a> | <a href="http://macaulay2.com/">Macaulay2 website</a>          </div>
</td>      </tr>
    </table>
    <div>
<a title="versal deformations of modules on hypersurfaces" href="index.html">ModuleDeformations</a> :: <a title="deformation in the absolute case" href="_deform__M__C__M__Module_lp__Module_rp.html">deformMCMModule(Module)</a>    </div>
    <hr/>
    <div>
      <h1>deformMCMModule(Module) -- deformation in the absolute case</h1>
      <div>
        <h2>Synopsis</h2>
        <ul>
          <li>
<span>Function: <a title="versal deformation of MCM-module on hypersurface" href="_deform__M__C__M__Module.html">deformMCMModule</a></span>          </li>
          <li>
            <dl class="element">
              <dt>Usage: </dt>
              <dd><code class="language-macaulay2">deformMCMModule M0</code></dd>
            </dl>
          </li>
          <li>
Inputs:            <ul>
              <li>
<span><tt>M0</tt>, <span>a <a title="the class of all modules" href="../../Macaulay2Doc/html/___Module.html">module</a></span>, the module to be deformed; it must be maximal Cohen-Macaulay</span>              </li>
            </ul>
          </li>
          <li>
<a href="../../Macaulay2Doc/html/_using_spfunctions_spwith_spoptional_spinputs.html">Optional inputs</a>:            <ul>
              <li>
<span><a title="Compute only up to this exponent" href="_deform__M__C__M__Module_lp..._cm__Degree__Limit_eq_gt..._rp.html">DegreeLimit</a><tt> => </tt><tt>...</tt>, <span>default value 10</span>, Compute only up to this exponent</span>              </li>
            </ul>
          </li>
          <li>
Outputs:            <ul>
              <li>
<span><tt>S</tt>, <span>a <a title="the class of all rings" href="../../Macaulay2Doc/html/___Ring.html">ring</a></span>, a ring representing the base space of the versal deformation of <tt>M0</tt></span>              </li>
              <li>
<span><tt>M</tt>, <span>a <a title="the class of all modules" href="../../Macaulay2Doc/html/___Module.html">module</a></span>, a module representing the module of the versal deformation</span>              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div>
        <h2>Description</h2>
This interface to <tt>deformMCMModule</tt> computes a deformation in the absolute case. Its inputs consist only of the module <tt>M0</tt> to deform.        <p/>
If <tt>M0</tt> is free, then <tt>deformMCMModule</tt> returns <tt>(QQ[], M)</tt>, where <tt>M</tt> is isomorphic as a graded module to <tt>M0</tt>.        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i1 : R = QQ[x,y, Degrees => {3,4}]/(x^4-y^3);</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i2 : deformMCMModule R^1

             1
o2 = (QQ[], R )

o2 : Sequence</code></pre>
</td>          </tr>
        </table>
        <p/>
The next example computes a versal deformation of the maximal ideal of the E6 singularity. The deformation theory of this module is equivalent to that of the residue field, whose versal deformation is the Hilbert scheme of one point on the singularity.         <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i3 : M0 = truncate(1,R^1)

o3 = image | x y |

                             1
o3 : R-module, submodule of R</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i4 : (S,M) = deformMCMModule M0

o4 = (S, cokernel {3} | y+xi_1  x3-x2xi_2+xxi_2^2-xi_2^3 |)
                  {4} | -x-xi_2 -y2+yxi_1-xi_1^2         |

o4 : Sequence</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i5 : prune S

     QQ[xi ..xi ]
          1    2
o5 = ------------
          3     4
      - xi  - xi
          1     2

o5 : QuotientRing</code></pre>
</td>          </tr>
        </table>
The base space of the deformation is therefore isomorphic to the singularity itself. The substitution <tt>x => -xi_2, y => xi_1</tt> shows that this is indeed the case with the result of the computation above.        <p/>
The resulting module $M$, when restricted to the product of the singularity with the base space, is isomorphic to the ideal defining the diagonal embedding of the singularity.        <p/>
The following example demonstrates the performance advantage of making use of a graded structure when possible. We deform the ideal generated by $ x^2, xy $ and $ y^2 $ of the $ E_6 $ curve singularity. In the first case, the module is input as a graded module.        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i6 : use R;  </code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i7 : N0 = module ideal (x^2,y^2)

o7 = image | x2 y2 |

                             1
o7 : R-module, submodule of R</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i8 : (S,N) = time deformMCMModule N0 
     -- used 1.85949 seconds

o8 = (S, cokernel {6} | x2-xxi_2-xi_1+xi_2^2-yxi_4^2-2xi_3xi_4^2+xi_2xi_4^3
                  {8} | xxi_4-y+xi_3                                       
     ------------------------------------------------------------------------
     xyxi_4+2xxi_3xi_4-xxi_2xi_4^2+y2+yxi_3+xi_3^2-xi_1xi_4^2 |)
     -x2-xxi_2-xi_1                                           |

o8 : Sequence</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i9 : prune S

                                                    QQ[xi ..xi ]
                                                         1    4
o9 = ---------------------------------------------------------------------------------------------------------
          2        2     3            2           3                3      2               2        3     2  3
     (- xi  + xi xi  + xi  - 3xi xi xi  + xi xi xi , - 2xi xi  + xi  + 3xi xi  - 3xi xi xi  - xi xi  + xi xi )
          1     1  2     3      1  3  4     1  2  4       1  2     2      3  4      2  3  4     1  4     2  4

o9 : QuotientRing</code></pre>
</td>          </tr>
        </table>
In the second case, we strip the grading from the module and rerun the computation.        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i10 : N0' = coker matrix entries presentation N0

o10 = cokernel | x2 y2  |
               | -y -x2 |

                             2
o10 : R-module, quotient of R</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i11 : (S',N') = time deformMCMModule N0'
     -- used 2.22377 seconds

o11 = (S', cokernel | x2-xxi_4^3-xxi_2+xi_2xi_4^3-3xi_3xi_4^2+xi_2^2-xi_1
                    | xxi_4-y+xi_3                                       
      -----------------------------------------------------------------------
      x2xi_4^2+xyxi_4+2xxi_3xi_4+y2+yxi_3+xi_3^2 |)
      -x2-xxi_2-xi_1                             |

o11 : Sequence</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i12 : prune S'

                                                   QQ[xi ..xi ]
                                                        1    4
o12 = -----------------------------------------------------------------------------------------------------
               3            2        2     3     2    2  3            2        3     3      2
      (xi xi xi  - 3xi xi xi  + xi xi  + xi  - xi , xi xi  - 3xi xi xi  - xi xi  + xi  + 3xi xi  - 2xi xi )
         1  2  4      1  3  4     1  2     3     1    2  4      2  3  4     1  4     2      3  4      1  2

o12 : QuotientRing</code></pre>
</td>          </tr>
        </table>
On the author's computer, the second computation takes approximately of 10% more processor time as the first. The user may see by inspection that the outputs of the two computations are isomorphic. More complicated examples, such as the square of the maximal ideal, show a much greater difference.      </div>
      <div class="waystouse">
        <h2>Ways to use this method:</h2>
        <ul>
          <li>
<span><a title="deformation in the absolute case" href="_deform__M__C__M__Module_lp__Module_rp.html">deformMCMModule(Module)</a> -- deformation in the absolute case</span>          </li>
        </ul>
      </div>
    </div>
  </body>

</html>
