<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>pushForward(RingMap,Module)</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <link type="text/css" rel="stylesheet" href="../../../../Macaulay2/Style/doc.css"/>

    <link rel="stylesheet" href="../../../../Macaulay2/Style/katex/katex.min.css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/katex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/auto-render.min.js"></script>
    <script defer="defer" type="text/javascript">
      var macros = {
          "\\break": "\\\\",
          "\\ZZ": "\\mathbb{Z}",
          "\\NN": "\\mathbb{N}",
          "\\QQ": "\\mathbb{Q}",
          "\\RR": "\\mathbb{R}",
          "\\CC": "\\mathbb{C}",
          "\\PP": "\\mathbb{P}"
      }, delimiters = [
          { left: "$$",  right: "$$",  display: true},
          { left: "\\[", right: "\\]", display: true},
          { left: "$",   right: "$",   display: false},
          { left: "\\(", right: "\\)", display: false}
      ], ignoredTags = ["tt", "script", "noscript", "style", "textarea", "pre", "code", "option"];
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, { delimiters: delimiters, macros: macros, ignoredTags: ignoredTags, trust: true });
      });
    </script>
    <style type="text/css">.katex { font-size: 1em; }</style>
    <link href="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.css" rel="stylesheet" type="text/css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/render-a11y-string.min.js"></script>
    <script type="text/javascript" src="../../../../Macaulay2/Style/highlight.js"></script>
  </head>
  <body>
    <table class="buttons">
      <tr>
<td>          <div>
<a href="___Q__Q.html">next</a> | <a href="_pseudo__Remainder.html">previous</a> | <a href="___Q__Q.html">forward</a> | <a href="_pseudo__Remainder.html">backward</a> | up | <a href="index.html">top</a> | <a href="master.html">index</a> | <a href="toc.html">toc</a> | <a href="http://macaulay2.com/">Macaulay2 website</a>          </div>
</td>      </tr>
    </table>
    <div>
<a title="Macaulay2 documentation" href="index.html">Macaulay2Doc</a> :: <a href="_push__Forward_lp__Ring__Map_cm__Module_rp.html">pushForward(RingMap,Module)</a>    </div>
    <hr/>
    <div>
      <h1>pushForward(RingMap,Module)</h1>
      <div>
        <h2>Synopsis</h2>
        <ul>
          <li>
<span>Function: <a href="_push__Forward_lp__Ring__Map_cm__Module_rp.html">pushForward</a></span>          </li>
          <li>
            <dl class="element">
              <dt>Usage: </dt>
              <dd><code class="language-macaulay2">pushForward(F,M)</code></dd>
            </dl>
          </li>
          <li>
Inputs:            <ul>
              <li>
<span><tt>F</tt>, <span>a <a title="the class of all ring maps" href="___Ring__Map.html">ring map</a></span>, a ring map F: R --> S, graded</span>              </li>
              <li>
<span><tt>M</tt>, <span>a <a title="the class of all modules" href="___Module.html">module</a></span>, over S, graded</span>              </li>
            </ul>
          </li>
          <li>
<a href="_using_spfunctions_spwith_spoptional_spinputs.html">Optional inputs</a>:            <ul>
              <li>
<span><tt>MonomialOrder</tt><tt> => </tt><tt>...</tt>, <span>default value Eliminate</span>, the type of monomial ordering to use in the computation, as keyword, either <a title="elimination order" href="___Eliminate.html">Eliminate</a>, <a title="product ordering" href="___Product__Order.html">ProductOrder</a>, or <a title="lexicographical monomial order." href="___Lex.html">Lex</a></span>              </li>
              <li>
<span><tt>UseHilbertFunction</tt><tt> => </tt><span>a <a title="the class of Boolean values" href="___Boolean.html">Boolean value</a></span>, <span>default value true</span>, whether to use the Hilbert function as a hint for the Gröbner basis computation, if <tt>M</tt> and <tt>F</tt> are homogeneous</span>              </li>
              <li>
<span><tt>StopBeforeComputation</tt><tt> => </tt><span>a <a title="the class of Boolean values" href="___Boolean.html">Boolean value</a></span>, <span>default value false</span>, see <a title="compute a Gröbner basis" href="_gb.html">gb(...,StopBeforeComputation=>...)</a></span>              </li>
              <li>
<span><tt>DegreeLimit</tt><tt> => </tt><span>a <a title="the class of Boolean values" href="___Boolean.html">Boolean value</a></span>, <span>default value {}</span>, see <a title="compute a Gröbner basis" href="_gb.html">gb(...,DegreeLimit=>...)</a></span>              </li>
              <li>
<span><tt>PairLimit</tt><tt> => </tt><span>a <a title="the class of Boolean values" href="___Boolean.html">Boolean value</a></span>, <span>default value infinity</span>, see <a title="compute a Gröbner basis" href="_gb.html">gb(...,PairLimit=>...)</a></span>              </li>
              <li>
<span><tt>Strategy</tt> (missing documentation)<!--tag: [pushForward, Strategy]-->
<tt> => </tt><tt>...</tt>, <span>default value null</span>, </span>              </li>
            </ul>
          </li>
          <li>
Outputs:            <ul>
              <li>
<span><span>a <a title="the class of all modules" href="___Module.html">module</a></span>, M, considered as an R-module</span>              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div>
        <h2>Description</h2>
Currently, <tt>R</tt> and <tt>S</tt> must both be polynomial rings over the same base field.        <p/>
This function first checks to see whether M will be a finitely generated R-module via F.  If not, an error message describing the codimension of M/(vars of S)M is given (this is equal to the dimension of R if and only if M is a finitely generated R-module.        <p/>
Assuming that it is, the push forward <tt>F_*(M)</tt> is computed.  This is done by first finding a presentation for <tt>M</tt> in terms of a set of elements that generates <tt>M</tt> as an <tt>S</tt>-module, and then applying the routine <a title="coimage of a map" href="_coimage.html">coimage</a> to a map whose target is <tt>M</tt> and whose source is a free module over <tt>R</tt>.        <h2>Example: The Auslander-Buchsbaum formula</h2>
Let's illustrate the Auslander-Buchsbaum formula. First construct some rings and make a module of projective dimension 2.        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i1 : R4 = ZZ/32003[a..d];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i2 : R5 = ZZ/32003[a..e];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i3 : R6 = ZZ/32003[a..f];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i4 : M = coker genericMatrix(R6,a,2,3)

o4 = cokernel | a c e |
              | b d f |

                              2
o4 : R6-module, quotient of R6</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i5 : pdim M

o5 = 2</code></pre>
</td>          </tr>
        </table>
Create ring maps.        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i6 : G = map(R6,R5,{a+b+c+d+e+f,b,c,d,e})

o6 = map (R6, R5, {a + b + c + d + e + f, b, c, d, e})

o6 : RingMap R6 &lt;--- R5</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i7 : F = map(R5,R4,random(R5^1, R5^{4:-1}))

o7 = map (R5, R4, {107a + 4376b - 5570c + 3187d + 3783e, - 5307a + 8570b - 15344c + 8444d - 10480e, 10359a - 7464b - 8251c + 2653d + 5071e, - 6203a + 12365b - 13508c - 9480d - 11950e})

o7 : RingMap R5 &lt;--- R4</code></pre>
</td>          </tr>
        </table>
The module M, when thought of as an R5 or R4 module, has the same depth, but since depth M + pdim M = dim ring, the projective dimension will drop to 1, respectively 0, for these two rings.        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i8 : P = pushForward(G,M)

o8 = cokernel | c -de               |
              | d bc-ad+bd+cd+d2+de |

                              2
o8 : R5-module, quotient of R5</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i9 : pdim P

o9 = 1</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i10 : Q = pushForward(F,P)

        3
o10 = R4

o10 : R4-module, free, degrees {0..1, 0}</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i11 : pdim Q

o11 = 0</code></pre>
</td>          </tr>
        </table>
        <h2>Example: generic projection of a homogeneous coordinate ring</h2>
We compute the pushforward N of the homogeneous coordinate ring M of the twisted cubic curve in P^3.        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i12 : P3 = QQ[a..d];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i13 : M = comodule monomialCurveIdeal(P3,{1,2,3})

o13 = cokernel | c2-bd bc-ad b2-ac |

                               1
o13 : P3-module, quotient of P3</code></pre>
</td>          </tr>
        </table>
The result is a module with the same codimension, degree and genus as the twisted cubic, but the support is a cubic in the plane, necessarily having one node.        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i14 : P2 = QQ[a,b,c];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i15 : F = map(P3,P2,random(P3^1, P3^{-1,-1,-1}))

                    8         4    4   9    5    8    10   3    1     7    2
o15 = map (P3, P2, {-a + 2b + -c + -d, -a + -b + -c + --d, -a + -b + --c + -d})
                    9         7    7   7    2    7     7   7    3    10    3

o15 : RingMap P3 &lt;--- P2</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i16 : N = pushForward(F,M)

o16 = cokernel {0} | 2746576531440ab-2534266045640b2-24211900548045ac+23443561995420bc-14394825893700c2 41713631071245a2-35589962516920b2-617284418550345ac+601115991475020bc-382187702981700c2 3911698210192282843849600b3-66754622794389240566784600b2c-3649526991392070087758253375ac2+3478861359062826352315326900bc2-2372019008234318457722851500c3                                   0                                                                                                                                                                       |
               {1} | -1917669755925a+2274660185954b-8894633060340c                                      -41832913217265a+52275870074434b-238856615455140c                                       -1498815844682001881230562400a2+2547688606736205330917173872ab-1049823644956341399785147872b2-3147838871484802066664262615ac+2570016678191191391969780310bc-2690990325409766765255811900c2 3104325504225a3-8141096469258a2b+7037566250256ab2-1999589995808b3+7766700637860a2c-13411647220680abc+5703323436000b2c+6283781809200ac2-5281643577600bc2+1508835384000c3 |

                               2
o16 : P2-module, quotient of P2</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i17 : hilbertPolynomial M

o17 = - 2*P  + 3*P
           0      1

o17 : ProjectiveHilbertPolynomial</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i18 : hilbertPolynomial N

o18 = - 2*P  + 3*P
           0      1

o18 : ProjectiveHilbertPolynomial</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i19 : ann N

                          3                 2                    2  
o19 = ideal(3104325504225a  - 8141096469258a b + 7037566250256a*b  -
      -----------------------------------------------------------------------
                    3                 2                         
      1999589995808b  + 7766700637860a c - 13411647220680a*b*c +
      -----------------------------------------------------------------------
                    2                    2                   2  
      5703323436000b c + 6283781809200a*c  - 5281643577600b*c  +
      -----------------------------------------------------------------------
                    3
      1508835384000c )

o19 : Ideal of P2</code></pre>
</td>          </tr>
        </table>
Note: these examples are from the original Macaulay script by David Eisenbud.      </div>
      <div>
        <h2>Caveat</h2>
The module M must be homogeneous, as must R, S, and f.  If you need this function in more general situations, please write it and send it to the Macaulay2 authors, or ask them to write it!      </div>
      <div class="waystouse">
        <h2>Ways to use this method:</h2>
        <ul>
          <li>
<span><a href="_push__Forward_lp__Ring__Map_cm__Module_rp.html">pushForward(RingMap,Module)</a></span>          </li>
        </ul>
      </div>
    </div>
  </body>

</html>
