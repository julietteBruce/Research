-- -*- M2-comint -*- hash: -1949200667

i1 : KK = ZZ/31991

o1 = KK

o1 : QuotientRing

i2 : SE = KK[x,y,z]/(y^2*z - x*(x-z)*(x+3*z))

o2 = SE

o2 : QuotientRing

i3 : purify1S2 = I -> (
         -- Assuming ring I is S2, and I is not 0, returns the 
         -- pure codimension 1 part of I.
         -- Find a nonzero element of I:
         M := compress gens I;
         -- Explanation: gens I is 
         -- the matrix of generators of I; compress
         -- removes the entries that are 0
         -- and := makes M a local variable.
         if numgens source M == 0 
         then error "purify1S2: expected nonzero ideal";
         f := ideal M_(0,0);
         -- f is the ideal generated by the first entry.
         -- Since ring I is S2, the ideal f is 
         -- pure codimension 1.  Thus
         f:(f:I)
         -- is the pure codimension 1 part. (The last 
         -- expression given in a function is the returned
         -- value, provided the semicolon is left off.)
         )

o3 = purify1S2

o3 : FunctionClosure

i4 : R = ZZ/5[a,b]

o4 = R

o4 : PolynomialRing

i5 : purify1S2 ideal(a^2,a*b)

o5 = ideal a

o5 : Ideal of R

i6 : Divisor = new Type of BasicList

o6 = Divisor

o6 : Type

i7 : divisor = method()

o7 = divisor

o7 : MethodFunction

i8 : divisor(Ideal,Ideal) := (I,J) -> new Divisor from {purify1S2 I,purify1S2 J};

i9 : divisor Ideal := I -> divisor(I, ideal 1_(ring I));

i10 : P = divisor ideal(x,z)

o10 = Divisor{ideal (z, x), ideal 1}

o10 : Divisor

i11 : R = divisor ideal(x,y)

o11 = Divisor{ideal (y, x), ideal 1}

o11 : Divisor

i12 : R1 = divisor ideal(x-z,y)

o12 = Divisor{ideal (y, x - z), ideal 1}

o12 : Divisor

i13 : R2 = divisor ideal(x+3*z,y)

o13 = Divisor{ideal (y, x + 3z), ideal 1}

o13 : Divisor

i14 : Q1 = divisor ideal(y-6*z, x-3*z)

o14 = Divisor{ideal (y - 6z, x - 3z), ideal 1}

o14 : Divisor

i15 : normalForm = method()

o15 = normalForm

o15 : MethodFunction

i16 : normalForm Divisor := D -> new Divisor from {D#0 : D#1, D#1 : D#0};

i17 : Divisor == Divisor := (D,E) -> toList normalForm D == toList normalForm E;

i18 : D = divisor(ideal(y, x^2+2*x*z-3*z^2), ideal(x-z, y))

                         2            2
o18 = Divisor{ideal (y, x  + 2x*z - 3z ), ideal (y, x - z)}

o18 : Divisor

i19 : normalForm D

o19 = Divisor{ideal (y, x + 3z), ideal 1}

o19 : Divisor

i20 : D == R2

o20 = true

i21 : Divisor + Divisor := (D,E) -> divisor(D#0 * E#0, D#1 * E#1);

i22 : - Divisor := (D) -> new Divisor from {D#1, D#0};

i23 : Divisor - Divisor := (D,E) -> D + (-E);

i24 : ZZ Divisor := ZZ * Divisor := (n,D) -> divisor((D#0)^n, (D#1)^n);

i25 : 2 P

                         2
o25 = Divisor{ideal (z, x ), ideal 1}

o25 : Divisor

i26 : 3 P

o26 = Divisor{ideal z, ideal 1}

o26 : Divisor

i27 : D = P-R1

o27 = Divisor{ideal (z, x), ideal (y, x - z)}

o27 : Divisor

i28 : D2 = 2 P - 2 R1

                         2                  2
o28 = Divisor{ideal (z, x ), ideal (x - z, y )}

o28 : Divisor

i29 : D = 2 P

                         2
o29 = Divisor{ideal (z, x ), ideal 1}

o29 : Divisor

i30 : I = D#0

                 2
o30 = ideal (z, x )

o30 : Ideal of SE

i31 : J = D#1

o31 = ideal 1

o31 : Ideal of SE

i32 : f = z

o32 = z

o32 : SE

i33 : LD = basis(degree f, purify1S2((f*J) : I))

o33 = {1} | 1 0 |
      {1} | 0 1 |

o33 : Matrix

i34 : LD = super (LD ** (ring target LD))

o34 = | z x |

               1        2
o34 : Matrix SE  <--- SE

i35 : imI = purify1S2(((z+x)*I) : z)

                     2     2
o35 = ideal (x + z, y  - 4z )

o35 : Ideal of SE

i36 : degree imI

o36 = 2

i37 : globalSections = method()

o37 = globalSections

o37 : MethodFunction

i38 : globalSections Divisor := (D) -> (
          -- First let's grab the parts (I,J) of D.
          I := D#0;
          J := D#1;
          -- Let 'f' be the first element of the 
          -- matrix of generators of the ideal I.
          f := (gens I)_(0,0);
          -- Now compute the basis of global sections
          -- just as above
          LD := basis(degree f, purify1S2((f*J) : I));
          LD = super (LD ** (ring target LD));
          -- Return both this vector space and the denominator
          {LD, f});

i39 : sectionIdeal = (f,g,D) -> (
          I := D#0;
          J := D#1;
          purify1S2((f*I):g) : J
          );

i40 : D = 4 P

                      2
o40 = Divisor{ideal (z , x*z), ideal 1}

o40 : Divisor

i41 : L = globalSections D

                         2
o41 = {| xz yz z2 x2 |, z }

o41 : List

i42 : phi = map(SE, ZZ/31991[a..d], L#0)

                                     2   2
o42 = map (SE, KK[a..d], {x*z, y*z, z , x })

o42 : RingMap SE <--- KK[a..d]

i43 : ker phi

              2                       2
o43 = ideal (b  + 3a*c - a*d - 2c*d, a  - c*d)

o43 : Ideal of KK[a..d]

i44 : D = 4 P - R

                      2
o44 = Divisor{ideal (z , x*z), ideal (y, x)}

o44 : Divisor

i45 : L = globalSections D

                      2
o45 = {| yz xz x2 |, z }

o45 : List

i46 : II = sectionIdeal(y*z+x*z+x^2, z^2, D)

              2                  2                2   2
o46 = ideal (y  + 3x*z + y*z + 3z , x*y + x*z - 3z , x  + x*z + y*z)

o46 : Ideal of SE

i47 : degree II

o47 = 3

i48 : globalSections (P-R)

o48 = {0, z}

o48 : List

i49 : D = 2 P - 2 R

                         2              2
o49 = Divisor{ideal (z, x ), ideal (x, y )}

o49 : Divisor

i50 : LB = globalSections D

o50 = {| x |, z}

o50 : List

i51 : linearlyEquivalent = (D,E) -> (
          F := normalForm(D-E);
          LB := globalSections F;
          L := LB#0;
          -- L is the matrix of numerators. Thus numgens source L
          -- is the dimension of the space of global sections.
          if numgens source L != 1 
          then false
          else (
              R := ring L;
              V := sectionIdeal(L_(0,0), LB#1, F);
              if V == ideal(1_R) 
                then L_(0,0)/LB#1
                else false)
          );

i52 : linearlyEquivalent(P,R)

o52 = false

i53 : linearlyEquivalent(2 P, 2 R)

      x
o53 = -
      z

o53 : frac SE

i54 : effective = (D) -> (
          LB := globalSections D;
          L := LB#0;  -- the matrix of numerators
          if numgens source L == 0 
          then error(toString D + " is not effective")
          else divisor sectionIdeal(L_(0,0), LB#1, D));

i55 : effective(2 R - P)

o55 = Divisor{ideal (z, x), ideal 1}

o55 : Divisor

i56 : addition = (R,S) -> effective(R + S - P);

i57 : addition(R1,R2)

o57 = Divisor{ideal (y, x), ideal 1}

o57 : Divisor

i58 : Q2 = addition(Q1, Q1)

o58 = Divisor{ideal (y, x - z), ideal 1}

o58 : Divisor

i59 : Q3 = addition(Q2, Q1)

o59 = Divisor{ideal (y + 6z, x - 3z), ideal 1}

o59 : Divisor

i60 : Q4 = addition(Q3, Q1)

o60 = Divisor{ideal (z, x), ideal 1}

o60 : Divisor

i61 : Q4a = addition(Q2,Q2)

o61 = Divisor{ideal (z, x), ideal 1}

o61 : Divisor

i62 : S = ZZ/31991[a,b,c,d];

i63 : catalect = map(S^2, 3, (i,j)->S_(i+j))

o63 = | a b c |
      | b c d |

              2       3
o63 : Matrix S  <--- S

i64 : IC = minors(2, catalect)

                2                        2
o64 = ideal (- b  + a*c, - b*c + a*d, - c  + b*d)

o64 : Ideal of S

i65 : SX = S/IC

o65 = SX

o65 : QuotientRing

i66 : KX = Ext^2(coker gens IC,S^{-4})

o66 = cokernel {1} | c  b  a  |
               {1} | -d -c -b |

                             2
o66 : S-module, quotient of S

i67 : canpres = substitute(presentation(KX), SX)

o67 = {1} | c  b  a  |
      {1} | -d -c -b |

               2        3
o67 : Matrix SX  <--- SX

i68 : betti canpres

             0 1
o68 = total: 2 3
          1: 2 3

o68 : BettiTally

i69 : I1 = transpose (syz transpose canpres)_{0}

o69 = | d c |

               1        2
o69 : Matrix SX  <--- SX

i70 : dg = (degrees (target I1))_0_0

o70 = 0

i71 : divisorFromModule = M -> (
        -- given a module M, returns the divisor of the image
        -- of a nonzero homomorphism to R, suitably twisted.
        -- first get the presentation of M
          I1 := transpose (syz transpose presentation M)_{0};
        -- The degree is
          d := (degrees target I1)_0_0;
        -- We need to balance the degree d with a power
        -- of the first nonzero generator of the ring.
          var1 := (compress vars ring M)_{0};
        -- Now fix up the degrees.
          if d==0 then divisor ideal I1
          else if d>0 then divisor(
                        ideal (I1**dual(target I1)),
                        ideal var1^d
                       )                          
          else divisor ideal( 
                     var1^(-d)**I1**dual target I1
                     )
      );

i72 : M = coker canpres

o72 = cokernel {1} | c  b  a  |
               {1} | -d -c -b |

                               2
o72 : SX-module, quotient of SX

i73 : divisorFromModule M

o73 = Divisor{ideal (d, c), ideal 1}

o73 : Divisor

i74 : use SX

o74 = SX

o74 : QuotientRing

i75 : divisorFromModule image matrix{{d^2}}

                              2
o75 = Divisor{ideal 1, ideal a }

o75 : Divisor

i76 : divisorFromModule SX^{1}

o76 = Divisor{ideal a, ideal 1}

o76 : Divisor

i77 : canonicalDivisor= SX ->(
        -- Given a ring SX, computes a canonical divisor for SX
        I := ideal presentation SX;
        S := ring I;
        embcodim := codim I;
        M := Ext^embcodim(coker gens I,S^{-numgens S});
        M = coker substitute(presentation M, SX);
        divisorFromModule M
        );

i78 : canonicalDivisor SX

o78 = Divisor{ideal (d, c), ideal 1}

o78 : Divisor

i79 : 
