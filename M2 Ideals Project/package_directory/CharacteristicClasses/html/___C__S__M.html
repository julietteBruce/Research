<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>CSM -- The Chern-Schwartz-MacPherson class</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <link type="text/css" rel="stylesheet" href="../../../../Macaulay2/Style/doc.css"/>

    <link rel="stylesheet" href="../../../../Macaulay2/Style/katex/katex.min.css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/katex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/auto-render.min.js"></script>
    <script defer="defer" type="text/javascript">
      var macros = {
          "\\break": "\\\\",
          "\\ZZ": "\\mathbb{Z}",
          "\\NN": "\\mathbb{N}",
          "\\QQ": "\\mathbb{Q}",
          "\\RR": "\\mathbb{R}",
          "\\CC": "\\mathbb{C}",
          "\\PP": "\\mathbb{P}"
      }, delimiters = [
          { left: "$$",  right: "$$",  display: true},
          { left: "\\[", right: "\\]", display: true},
          { left: "$",   right: "$",   display: false},
          { left: "\\(", right: "\\)", display: false}
      ], ignoredTags = ["tt", "script", "noscript", "style", "textarea", "pre", "code", "option"];
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, { delimiters: delimiters, macros: macros, ignoredTags: ignoredTags, trust: true });
      });
    </script>
    <style type="text/css">.katex { font-size: 1em; }</style>
    <link href="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.css" rel="stylesheet" type="text/css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/render-a11y-string.min.js"></script>
    <script type="text/javascript" src="../../../../Macaulay2/Style/highlight.js"></script>
  </head>
  <body>
    <table class="buttons">
      <tr>
<td>          <div>
<a href="___Euler.html">next</a> | <a href="_configuring_sp__Bertini.html">previous</a> | <a href="___Euler.html">forward</a> | <a href="_configuring_sp__Bertini.html">backward</a> | up | <a href="index.html">top</a> | <a href="master.html">index</a> | <a href="toc.html">toc</a> | <a href="http://macaulay2.com/">Macaulay2 website</a>          </div>
</td>      </tr>
    </table>
    <div>
<a title="Chern classes and other characteristic classes of subschemes of certain smooth toric varieties, including products of projective spaces" href="index.html">CharacteristicClasses</a> :: <a title="The Chern-Schwartz-MacPherson class" href="___C__S__M.html">CSM</a>    </div>
    <hr/>
    <div>
      <h1>CSM -- The Chern-Schwartz-MacPherson class</h1>
      <div>
        <h2>Synopsis</h2>
        <ul>
          <li>
            <dl class="element">
              <dt>Usage: </dt>
              <dd><code class="language-macaulay2">CSM I</code></dd>
              <dd><code class="language-macaulay2">CSM(A,I)</code></dd>
              <dd><code class="language-macaulay2">CSM(A,I,M)</code></dd>
              <dd><code class="language-macaulay2">CSM(X,J)</code></dd>
              <dd><code class="language-macaulay2">CSM(Ch,X,J)</code></dd>
              <dd><code class="language-macaulay2">CSM(Ch,X,J,M)</code></dd>
              <dd><code class="language-macaulay2">CSM X</code></dd>
              <dd><code class="language-macaulay2">CSM(Ch,X)</code></dd>
              <dd><code class="language-macaulay2">CSM(I,h)</code></dd>
            </dl>
          </li>
          <li>
Inputs:            <ul>
              <li>
<span><tt>I</tt>, <span>an <a title="the class of all ideals" href="../../Macaulay2Doc/html/___Ideal.html">ideal</a></span>, a multi-homogeneous ideal in a graded polynomial ring over a field defining a closed subscheme V of \PP^{n_1}x...x\PP^{n_m}</span>              </li>
              <li>
<span><tt>A</tt>, <span>a <a title="the class of all quotient rings" href="../../Macaulay2Doc/html/___Quotient__Ring.html">quotient ring</a></span>, A=\ZZ[h_1,...,h_m]/(h_1^{n_1+1},...,h_m^{n_m+1}) quotient ring representing the Chow ring of \PP^{n_1}x...x\PP^{n_m}, this ring should be built using the <a title="Computes the Chow ring of a product of projective spaces m projective spaces given the coordinate ring" href="___Chow__Ring.html">ChowRing</a> command</span>              </li>
              <li>
<span><tt>J</tt>, <span>an <a title="the class of all ideals" href="../../Macaulay2Doc/html/___Ideal.html">ideal</a></span>, an ideal in the graded polynomial ring which is coordinate ring of the Normal Toric Variety X</span>              </li>
              <li>
<span><tt>X</tt>, <span>a <a title="the class of all normal toric varieties" href="../../NormalToricVarieties/html/___Normal__Toric__Variety.html">normal toric variety</a></span>, which is the ambient space containing V(J)</span>              </li>
              <li>
<span><tt>Ch</tt>, <span>a <a title="the class of all quotient rings" href="../../Macaulay2Doc/html/___Quotient__Ring.html">quotient ring</a></span>, the Chow ring of the toric variety X, Ch=(ring J)/(SR+LR) where SR is the Stanley-Reisner ideal of the fan defining X and LR is the linear relations ideal, this ring should be built using the <a title="Computes the Chow ring of a normal toric variety" href="___Toric__Chow__Ring.html">ToricChowRing</a> command</span>              </li>
              <li>
<span><tt>h</tt>, <span>a <a title="the class of all symbols" href="../../Macaulay2Doc/html/___Symbol.html">symbol</a></span>, to be used as the intermediate for the Chow ring (this may only be used for subschemes of \PP^{n_1}x...x\PP^{n_m})</span>              </li>
              <li>
<span><tt>M</tt>, <span>a <a title="the class of all mutable hash tables" href="../../Macaulay2Doc/html/___Mutable__Hash__Table.html">mutable hash table</a></span>, containing known CSM classes of hypersurfaces appearing in the inclusion-exclusion procedure</span>              </li>
            </ul>
          </li>
          <li>
<a href="../../Macaulay2Doc/html/_using_spfunctions_spwith_spoptional_spinputs.html">Optional inputs</a>:            <ul>
              <li>
<span><tt>CompMethod</tt><tt> => </tt><tt>...</tt>, <span>default value ProjectiveDegree</span>, ProjectiveDegree, this is the default algorithm used for the main computational steps in the computation</span>              </li>
              <li>
<span><tt>CompMethod</tt><tt> => </tt><tt>...</tt>, <span>default value ProjectiveDegree</span>, PnResidual, this algorithm may be used for subschemes of \PP^n only</span>              </li>
              <li>
<span><tt>Method</tt><tt> => </tt><tt>...</tt>, <span>default value InclusionExclusion</span>, InclusionExclusion, this is the default method and is applicable for all inputs</span>              </li>
              <li>
<span><tt>Method</tt><tt> => </tt><tt>...</tt>, <span>default value InclusionExclusion</span>, DirectCompleteInt, this method may provide a performance improvement when the input is a complete intersection, if the input is not a complete intersection a warning will be given and the InclusionExclusion option will be used instead</span>              </li>
              <li>
<span><tt>CheckSmooth</tt><tt> => </tt><tt>...</tt>, <span>default value true</span>, this option is only used when computing the CSM class of a input toric variety X (not of a subscheme), if true it checks if the toric variety is smooth before computing its CSM class, this will lead to faster computation in the smooth cases</span>              </li>
              <li>
<span><tt>InputIsSmooth</tt><tt> => </tt><tt>...</tt>, <span>default value false</span>, this option has values true/false and tells the method whether to assume the input ideal defines a smooth scheme, and hence to call the method Chern instead for reduced run time, alternatively the Chern function can be used directly</span>              </li>
              <li>
<span><tt>Output</tt><tt> => </tt><tt>...</tt>, <span>default value ChowRingElement</span>, ChowRingElement, the type of output to return, &quot;ChowRingElement&quot; is default and returns a RingElement in the Chow ring of the appropriate ambient space</span>              </li>
              <li>
<span><tt>Output</tt><tt> => </tt><tt>...</tt>, <span>default value ChowRingElement</span>, HashForm, the type of output to return, HashForm returns a MutableHashTable containing the key &quot;CSM&quot; (the CSM class), and keys of the form \{0\},\{1\},\{2\},...,\{0,1\},\{0,2\} ....\{0,1,2\}... and so on which correspond to the indices of the possible subsets of the generators of the input ideal, for each set of indices the CSM class of the hypersurface given by the product of all polynomials in the corresponding set of generators is stored, there is no extra cost to using this option</span>              </li>
              <li>
<span><tt>IndsOfSmooth</tt><tt> => </tt><tt>...</tt>, <span>default value {}</span>, this option may speed up the run time when using the DirectCompleteInt Method if the user knows additional information about the input ideal, see <a href="___Inds__Of__Smooth.html">IndsOfSmooth</a></span>              </li>
            </ul>
          </li>
          <li>
Outputs:            <ul>
              <li>
<span><span>a <a title="the class of all ring elements handled by the engine" href="../../Macaulay2Doc/html/___Ring__Element.html">ring element</a></span>, the pushforward of the CSM class to the Chow ring of the appropriate ambient space</span>              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div>
        <h2>Description</h2>
        <div>
          <p>For a non-singular n-dimensional subscheme V of an applicable toric variety X, this command computes the push-forward of the total Chern class of V to the Chow ring of X. The output is an element of the Chow ring of X, that is a polynomial in the hyperplane classes h_1,...,h_m if X=\PP^{n_1}\times\PP^{n_m} is a product of projective space. Otherwise it is a polynomial in R/(SR+LR) where R is the Cox ring, SR the Stanely-Reilser Ideal and LR the ideal generated by linear relations among the rays.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i1 : kk=ZZ/32749;</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i2 : R=kk[x_0..x_4]

o2 = R

o2 : PolynomialRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i3 : I=ideal(random(1,R),random(2,R),x_0*x_2-x_3*x_0);

o3 : Ideal of R</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i4 : CSM(ideal I_0,CompMethod=>PnResidual)

       4     3     2
o4 = 4H  + 6H  + 4H  + H

     ZZ[H]
o4 : -----
        5
       H</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i5 : csmI=CSM(I)

       4     3
o5 = 2h  + 4h
       1     1

     ZZ[h ]
         1
o5 : ------
        5
       h
        1</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i6 : A=ring csmI

o6 = A

o6 : QuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i7 : csmIHash=CSM(A,I,Output=>HashForm);</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i8 : csmIHash#{0,1}==CSM(A,ideal(I_0*I_1))

o8 = true</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Note that the ideal above is a complete intersection, thus we may change the method option which may speed computation in some cases. We may also note that the ideal generated by the first 2 generators of I defines a smooth scheme and input this information into the method.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i9 : csmI==CSM(A,I,Method=>DirectCompleteInt)

o9 = true</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i10 : CSM(A,I,Method=>DirectCompleteInt,IndsOfSmooth=>{0,1})

        4     3
o10 = 2h  + 4h
        1     1

o10 : A</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Now consider an example in \PP^2 \times \PP^2, if we input the Chow ring A the output will be returned in the same ring. We may also return a MutableHashTable.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i11 : R=MultiProjCoordRing({2,2})

o11 = R

o11 : PolynomialRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i12 : A=ChowRing(R)

o12 = A

o12 : QuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i13 : r=gens R

o13 = {x , x , x , x , x , x }
        0   1   2   3   4   5

o13 : List</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i14 : K=ideal(r_0^2*r_3-r_4*r_1*r_2,r_2^2*r_5)

              2              2
o14 = ideal (x x  - x x x , x x )
              0 3    1 2 4   2 5

o14 : Ideal of R</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i15 : time csmK=CSM(A,K)
     -- used 0.419801 seconds

        2 2     2         2    2            2
o15 = 7h h  + 5h h  + 4h h  + h  + 3h h  + h
        1 2     1 2     1 2    1     1 2    2

o15 : A</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i16 : csmKHash= CSM(A,K,Output=>HashForm)

o16 = MutableHashTable{...4...}

o16 : MutableHashTable</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i17 : csmK==csmKHash#&quot;CSM&quot;

o17 = true</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i18 : CSM(A,ideal(K_0))==csmKHash#{0}

o18 = true</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Suppose we have already computed some of CSM classes of hypersurfaces involved in the inclusion-exclusion procedure, then we may input these to be used by the CSM function. In the example below we input the CSM class of V(K_0) (that is of the hypersurface defined by the first polynomial generating K) and the CSM class of the hypersurface defined by the product of the generators of K.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i19 : m=new MutableHashTable;</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i20 : m#{0}=csmKHash#{0}

        2 2     2         2     2             2
o20 = 8h h  + 7h h  + 6h h  + 2h  + 5h h  + 2h  + 2h  + h
        1 2     1 2     1 2     1     1 2     2     1    2

o20 : A</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i21 : m#{0,1}=csmKHash#{0,1}

        2 2     2         2     2             2
o21 = 9h h  + 9h h  + 9h h  + 3h  + 7h h  + 3h  + 3h  + 2h
        1 2     1 2     1 2     1     1 2     2     1     2

o21 : A</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i22 : time CSM(A,K,m)
     -- used 0.104523 seconds

        2 2     2         2    2            2
o22 = 7h h  + 5h h  + 4h h  + h  + 3h h  + h
        1 2     1 2     1 2    1     1 2    2

o22 : A</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>In the case where the ambient space is a toric variety which is not a product of projective spaces we must load the NormalToricVarieties package and must also input the toric variety. If the toric variety is a product of projective space it is recommend to use the form above rather than inputting the toric variety for efficiency reasons.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i23 : needsPackage &quot;NormalToricVarieties&quot;

o23 = NormalToricVarieties

o23 : Package</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i24 : Rho = {{1,0,0},{0,1,0},{0,0,1},{-1,-1,0},{0,0,-1}}

o24 = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}, {-1, -1, 0}, {0, 0, -1}}

o24 : List</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i25 : Sigma = {{0,1,2},{1,2,3},{0,2,3},{0,1,4},{1,3,4},{0,3,4}}

o25 = {{0, 1, 2}, {1, 2, 3}, {0, 2, 3}, {0, 1, 4}, {1, 3, 4}, {0, 3, 4}}

o25 : List</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i26 : X = normalToricVariety(Rho,Sigma,CoefficientRing =>ZZ/32749)

o26 = X

o26 : NormalToricVariety</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i27 : csmX=CSM X

        2       2
o27 = 6x x  + 3x  + 6x x  + 3x  + 2x  + 1
        3 4     3     3 4     3     4

                      ZZ[x ..x ]
                          0   4
o27 : -----------------------------------------
      (x x , x x x , x  - x , x  - x , x  - x )
        2 4   0 1 3   0    3   1    3   2    4</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i28 : Ch=ring csmX

o28 = Ch

o28 : QuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i29 : CheckToricVarietyValid(X)

o29 = true</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i30 : R=ring(X)

o30 = R

o30 : PolynomialRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i31 : I=ideal(R_0^4*R_1,R_0*R_3*R_4*R_2-R_2^2*R_0^2)

              4       2 2
o31 = ideal (x x , - x x  + x x x x )
              0 1     0 2    0 2 3 4

o31 : Ideal of R</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i32 : CSM(X,I)

        2       2
o32 = 5x x  + 3x  + 4x x  + x
        3 4     3     3 4    3

                      ZZ[x ..x ]
                          0   4
o32 : -----------------------------------------
      (x x , x x x , x  - x , x  - x , x  - x )
        2 4   0 1 3   0    3   1    3   2    4</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i33 : CSM(Ch,X,I)

        2       2
o33 = 8x x  + 3x  + 5x x  + x
        3 4     3     3 4    3

o33 : Ch</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>This function may also compute the CSM class of a normal toric variety defined by a fan. In this case a combinatorial method is used. This method is accessed with the usual CSM command with either only a toric variety or a toric variety and a Chow ring as input. In this case we only require that the input toric variety is complete and simplicial (in particular we do not need it to be smooth).</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i34 : needsPackage &quot;NormalToricVarieties&quot;

o34 = NormalToricVarieties

o34 : Package</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i35 : U = hirzebruchSurface 7

o35 = U

o35 : NormalToricVariety</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i36 : Ch=ToricChowRing(U)

o36 = Ch

o36 : QuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i37 : CSM U

                 2
o37 = - 3x x  + x  - 5x  + 2x  + 1
          2 3    3     2     3

                   ZZ[x ..x ]
                       0   3
o37 : ------------------------------------
      (x x , x x , x  - x , x  + 7x  - x )
        0 2   1 3   0    2   1     2    3</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i38 : csm1=CSM(Ch,U)

                 2
o38 = - 3x x  + x  - 5x  + 2x  + 1
          2 3    3     2     3

o38 : Ch</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>All the examples were done using symbolic computations with Gr\&quot;obner bases. Changing the option <a href="___Comp__Method.html">CompMethod</a> to bertini will do the main computations numerically, provided Bertini is <a href="_configuring_sp__Bertini.html">installed and configured</a>. Note that the bertini and PnResidual options may only be used for subschemes of \PP^n.</p>
          <p>Observe that the algorithm is a probabilistic algorithm and may give a wrong answer with a small but nonzero probability. Read more under <a href="_probabilistic_spalgorithm.html">probabilistic algorithm</a>.</p>
          <p></p>
        </div>
      </div>
      <div class="waystouse">
        <h2>Ways to use <tt>CSM</tt> :</h2>
        <ul>
          <li>
<tt>&quot;CSM(Ideal)&quot;</tt>          </li>
          <li>
<tt>&quot;CSM(Ideal,Symbol)&quot;</tt>          </li>
          <li>
<tt>&quot;CSM(QuotientRing,Ideal)&quot;</tt>          </li>
          <li>
<tt>&quot;CSM(QuotientRing,Ideal,MutableHashTable)&quot;</tt>          </li>
        </ul>
      </div>
      <div class="waystouse">
        <h2>For the programmer</h2>
        <p>The object <a title="The Chern-Schwartz-MacPherson class" href="___C__S__M.html">CSM</a> is <span>a <a title="a type of method function" href="../../Macaulay2Doc/html/___Method__Function__With__Options.html">method function with options</a></span>.</p>
      </div>
    </div>
  </body>

</html>
