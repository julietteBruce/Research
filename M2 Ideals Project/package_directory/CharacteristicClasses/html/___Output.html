<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>Output</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <link type="text/css" rel="stylesheet" href="../../../../Macaulay2/Style/doc.css"/>

    <link rel="stylesheet" href="../../../../Macaulay2/Style/katex/katex.min.css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/katex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/auto-render.min.js"></script>
    <script defer="defer" type="text/javascript">
      var macros = {
          "\\break": "\\\\",
          "\\ZZ": "\\mathbb{Z}",
          "\\NN": "\\mathbb{N}",
          "\\QQ": "\\mathbb{Q}",
          "\\RR": "\\mathbb{R}",
          "\\CC": "\\mathbb{C}",
          "\\PP": "\\mathbb{P}"
      }, delimiters = [
          { left: "$$",  right: "$$",  display: true},
          { left: "\\[", right: "\\]", display: true},
          { left: "$",   right: "$",   display: false},
          { left: "\\(", right: "\\)", display: false}
      ], ignoredTags = ["tt", "script", "noscript", "style", "textarea", "pre", "code", "option"];
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, { delimiters: delimiters, macros: macros, ignoredTags: ignoredTags, trust: true });
      });
    </script>
    <style type="text/css">.katex { font-size: 1em; }</style>
    <link href="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.css" rel="stylesheet" type="text/css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/render-a11y-string.min.js"></script>
    <script type="text/javascript" src="../../../../Macaulay2/Style/highlight.js"></script>
  </head>
  <body>
    <table class="buttons">
      <tr>
<td>          <div>
<a href="_probabilistic_spalgorithm.html">next</a> | <a href="___Multi__Proj__Coord__Ring.html">previous</a> | <a href="_probabilistic_spalgorithm.html">forward</a> | <a href="___Multi__Proj__Coord__Ring.html">backward</a> | up | <a href="index.html">top</a> | <a href="master.html">index</a> | <a href="toc.html">toc</a> | <a href="http://macaulay2.com/">Macaulay2 website</a>          </div>
</td>      </tr>
    </table>
    <div>
<a title="Chern classes and other characteristic classes of subschemes of certain smooth toric varieties, including products of projective spaces" href="index.html">CharacteristicClasses</a> :: <a href="___Output.html">Output</a>    </div>
    <hr/>
    <div>
      <h1>Output</h1>
      <div>
        <h2>Description</h2>
        <div>
          <p>The option Output is only used by the commands <a title="The Chern-Schwartz-MacPherson class" href="___C__S__M.html">CSM</a>, <a title="The Segre class of a subscheme" href="___Segre.html">Segre</a>, <a title="The Chern class" href="___Chern.html">Chern</a> and <a title="The Euler Characteristic" href="___Euler.html">Euler</a> to specify the type of output to be returned to the used. This option will be ignored when used with <a href="___Comp__Method.html">CompMethod</a> PnResidual or bertini. The option will also be ignore when <a href="___Method.html">Method</a>=>DirectCompleteInt is used. The default output for all these methods is ChowRingElelment which will return an element of the appropriate Chow ring. All methods also have an option HashForm which returns additional information computed by the methods during their standard operation.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i1 : R = ZZ/32749[x_0..x_6]

o1 = R

o1 : PolynomialRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i2 : A=ChowRing(R)

o2 = A

o2 : QuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i3 : I=ideal(random(2,R),R_0*R_1*R_6-R_0^3);

o3 : Ideal of R</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i4 : csm=CSM(A,I,Output=>HashForm)

o4 = MutableHashTable{...4...}

o4 : MutableHashTable</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i5 : peek csm

                                  6      5      4      3      2
o5 = MutableHashTable{{0, 1} => 2h  + 23h  + 32h  + 33h  + 18h  + 5h }
                                  1      1      1      1      1     1
                                6      5      4      3     2
                      CSM => 10h  + 12h  + 22h  + 16h  + 6h
                                1      1      1      1     1
                               6      5      4      3      2
                      {0} => 6h  + 18h  + 26h  + 22h  + 10h  + 2h
                               1      1      1      1      1     1
                               6      5      4      3      2
                      {1} => 6h  + 17h  + 28h  + 27h  + 14h  + 3h
                               1      1      1      1      1     1</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i6 : CSM(A,ideal I_0)==csm#{0}

o6 = true</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i7 : CSM(A,ideal(I_0*I_1))==csm#{0,1}

o7 = true</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i8 : c=Chern( I, Output=>HashForm)

o8 = MutableHashTable{...6...}

o8 : MutableHashTable</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i9 : peek c

                                            2      3      4       5       6
o9 = MutableHashTable{SegreList => {0, 0, 6h , -30h , 114h , -390h , 1266h }}
                                            1      1      1       1       1
                                          2    3    4    5    6
                      Glist => {1, 3h , 3h , 3h , 3h , 3h , 3h }
                                     1    1    1    1    1    1
                                    6       5       4      3     2
                      Segre => 1266h  - 390h  + 114h  - 30h  + 6h
                                    1       1       1      1     1
                                  6      5      4      3     2
                      Chern => 90h  - 12h  + 30h  + 12h  + 6h
                                  1      1      1      1     1
                               6      5      4      3     2
                      CF => 90h  - 12h  + 30h  + 12h  + 6h
                               1      1      1      1     1
                             6     5     4     3     2
                      G => 3h  + 3h  + 3h  + 3h  + 3h  + 3h  + 1
                             1     1     1     1     1     1</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i10 : seg=Segre( I, Output=>HashForm)

o10 = MutableHashTable{...4...}

o10 : MutableHashTable</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i11 : peek seg

                                             2      3      4       5       6
o11 = MutableHashTable{SegreList => {0, 0, 6h , -30h , 114h , -390h , 1266h }}
                                             1      1      1       1       1
                                           2    3    4    5    6
                       Glist => {1, 3h , 3h , 3h , 3h , 3h , 3h }
                                      1    1    1    1    1    1
                                     6       5       4      3     2
                       Segre => 1266h  - 390h  + 114h  - 30h  + 6h
                                     1       1       1      1     1
                              6     5     4     3     2
                       G => 3h  + 3h  + 3h  + 3h  + 3h  + 3h  + 1
                              1     1     1     1     1     1</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i12 : eu=Euler( I, Output=>HashForm)

o12 = MutableHashTable{...5...}

o12 : MutableHashTable</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i13 : peek eu

o13 = MutableHashTable{Euler => 10                                    }
                                   6      5      4      3      2
                       {0, 1} => 2h  + 23h  + 32h  + 33h  + 18h  + 5h
                                   1      1      1      1      1     1
                                 6      5      4      3     2
                       CSM => 10h  + 12h  + 22h  + 16h  + 6h
                                 1      1      1      1     1
                                6      5      4      3      2
                       {0} => 6h  + 18h  + 26h  + 22h  + 10h  + 2h
                                1      1      1      1      1     1
                                6      5      4      3      2
                       {1} => 6h  + 17h  + 28h  + 27h  + 14h  + 3h
                                1      1      1      1      1     1</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>The MutableHashTable returned with the option Output=>HashForm contains different information depending on the method with which it is used. Additionally if the option <a href="___Input__Is__Smooth.html">InputIsSmooth</a> is used then the hash table returned by the methods Euler and CSM will be the same as that returned by Chern. When using the <a title="The Chern-Schwartz-MacPherson class" href="___C__S__M.html">CSM</a>  command in the default configurations (that is <a href="___Method.html">Method</a>=>InclusionExclusion, <a href="___Comp__Method.html">CompMethod</a>=>ProjectiveDegree) there is the additional option to set Output=>HashFormXL. This returns all the usual information that Output=>HashForm would for this configuration with the addition of the projective degrees and Segre classes of singularity subschemes generated by the hypersurfaces considered in the inclusion/exclusion procedure, that is in finding the CSM class of all hypersurfaces generated by taking a product of some subsets of generators of the input ideal. Note that, since the CSM class of a subscheme equals the CSM class of its reduced scheme, or equivalently for us the CSM class corresponding to an ideal I equals the CSM class of the radical of I, then internally we always work with radical ideals (for efficiency reasons). Hence the projective degrees and Segre classes computed internally will be those of the radical of an ideal defined by a polynomial which is a product of some subset of the generators. We illustrate this with an example below.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i14 : csmXLhash=CSM(A,I,Output=>HashFormXL)

o14 = MutableHashTable{...10...}

o14 : MutableHashTable</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i15 : peek csmXLhash

o15 = MutableHashTable{G(Jacobian){0} => 0                                           }
                       Segre(Jacobian){0} => 0
                                                    6       5       4      3     2
                       Segre(Jacobian){0, 1} => 390h  - 386h  + 150h  - 42h  + 8h
                                                    1       1       1      1     1
                                                   6      5     3     2
                       Segre(Jacobian){1} => - 160h  + 32h  - 4h  + 2h
                                                   1      1     1     1
                                               6      5      4      3     2
                       G(Jacobian){0, 1} => 10h  + 10h  + 10h  + 10h  + 8h  + 4h  + 1
                                               1      1      1      1     1     1
                                           2
                       G(Jacobian){1} => 2h  + 2h  + 1
                                           1     1
                                   6      5      4      3      2
                       {0, 1} => 2h  + 23h  + 32h  + 33h  + 18h  + 5h
                                   1      1      1      1      1     1
                                 6      5      4      3     2
                       CSM => 10h  + 12h  + 22h  + 16h  + 6h
                                 1      1      1      1     1
                                6      5      4      3      2
                       {0} => 6h  + 18h  + 26h  + 22h  + 10h  + 2h
                                1      1      1      1      1     1
                                6      5      4      3      2
                       {1} => 6h  + 17h  + 28h  + 27h  + 14h  + 3h
                                1      1      1      1      1     1</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i16 : K=ideal I_0*I_1;

o16 : Ideal of R</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i17 : CSM(A,radical K)==CSM(A,K)

o17 = true</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i18 : J=ideal jacobian radical K;

o18 : Ideal of R</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i19 : segJ=Segre(A,J,Output=>HashForm)

o19 = MutableHashTable{...4...}

o19 : MutableHashTable</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i20 : csmXLhash#(&quot;G(Jacobian)&quot;|toString({0,1}))==segJ#&quot;G&quot;

o20 = true</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i21 : csmXLhash#(&quot;Segre(Jacobian)&quot;|toString({0,1}))==segJ#&quot;Segre&quot;

o21 = true</code></pre>
</td>          </tr>
        </table>
      </div>
      <div>
        <h2>Functions with optional argument named <tt>Output</tt> :</h2>
        <ul>
          <li>
<span><tt>&quot;Chern(...,Output=>...)&quot;</tt> -- see <span><a title="The Chern class" href="___Chern.html">Chern</a> -- The Chern class</span></span>          </li>
          <li>
<span><tt>&quot;CSM(...,Output=>...)&quot;</tt> -- see <span><a title="The Chern-Schwartz-MacPherson class" href="___C__S__M.html">CSM</a> -- The Chern-Schwartz-MacPherson class</span></span>          </li>
          <li>
<span><tt>&quot;Euler(...,Output=>...)&quot;</tt> -- see <span><a title="The Euler Characteristic" href="___Euler.html">Euler</a> -- The Euler Characteristic</span></span>          </li>
          <li>
<span><tt>&quot;Segre(...,Output=>...)&quot;</tt> -- see <span><a title="The Segre class of a subscheme" href="___Segre.html">Segre</a> -- The Segre class of a subscheme</span></span>          </li>
        </ul>
      </div>
      <div class="waystouse">
        <h2>For the programmer</h2>
        <p>The object <a href="___Output.html">Output</a> is <span>a <a title="the class of all symbols" href="../../Macaulay2Doc/html/___Symbol.html">symbol</a></span>.</p>
      </div>
    </div>
  </body>

</html>
