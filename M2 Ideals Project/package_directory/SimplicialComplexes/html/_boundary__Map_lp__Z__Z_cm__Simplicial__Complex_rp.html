<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>boundaryMap(ZZ,SimplicialComplex) -- make a boundary map between the oriented faces of an abstract simplicial complex</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <link type="text/css" rel="stylesheet" href="../../../../Macaulay2/Style/doc.css"/>

    <link rel="stylesheet" href="../../../../Macaulay2/Style/katex/katex.min.css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/katex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/auto-render.min.js"></script>
    <script defer="defer" type="text/javascript">
      var macros = {
          "\\break": "\\\\",
          "\\ZZ": "\\mathbb{Z}",
          "\\NN": "\\mathbb{N}",
          "\\QQ": "\\mathbb{Q}",
          "\\RR": "\\mathbb{R}",
          "\\CC": "\\mathbb{C}",
          "\\PP": "\\mathbb{P}"
      }, delimiters = [
          { left: "$$",  right: "$$",  display: true},
          { left: "\\[", right: "\\]", display: true},
          { left: "$",   right: "$",   display: false},
          { left: "\\(", right: "\\)", display: false}
      ], ignoredTags = ["tt", "script", "noscript", "style", "textarea", "pre", "code", "option"];
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, { delimiters: delimiters, macros: macros, ignoredTags: ignoredTags, trust: true });
      });
    </script>
    <style type="text/css">.katex { font-size: 1em; }</style>
    <link href="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.css" rel="stylesheet" type="text/css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/render-a11y-string.min.js"></script>
    <script type="text/javascript" src="../../../../Macaulay2/Style/highlight.js"></script>
  </head>
  <body>
    <table class="buttons">
      <tr>
<td>          <div>
<a href="_buchberger__Resolution.html">next</a> | <a href="_bjorner__Complex_lp__Polynomial__Ring_rp.html">previous</a> | <a href="_buchberger__Resolution.html">forward</a> | <a href="_bjorner__Complex_lp__Polynomial__Ring_rp.html">backward</a> | up | <a href="index.html">top</a> | <a href="master.html">index</a> | <a href="toc.html">toc</a> | <a href="http://macaulay2.com/">Macaulay2 website</a>          </div>
</td>      </tr>
    </table>
    <div>
<a title="exploring abstract simplicial complexes within commutative algebra" href="index.html">SimplicialComplexes</a> :: <a title="make a boundary map between the oriented faces of an abstract simplicial complex" href="_boundary__Map_lp__Z__Z_cm__Simplicial__Complex_rp.html">boundaryMap(ZZ,SimplicialComplex)</a>    </div>
    <hr/>
    <div>
      <h1>boundaryMap(ZZ,SimplicialComplex) -- make a boundary map between the oriented faces of an abstract simplicial complex</h1>
      <div>
        <h2>Synopsis</h2>
        <ul>
          <li>
<span>Function: <a title="make a boundary map between the oriented faces of an abstract simplicial complex" href="_boundary__Map_lp__Z__Z_cm__Simplicial__Complex_rp.html">boundaryMap</a></span>          </li>
          <li>
            <dl class="element">
              <dt>Usage: </dt>
              <dd><code class="language-macaulay2">boundaryMap(i, Delta)</code></dd>
            </dl>
          </li>
          <li>
Inputs:            <ul>
              <li>
<span><tt>i</tt>, <span>an <a title="the class of all integers" href="../../Macaulay2Doc/html/___Z__Z.html">integer</a></span>, specifying the dimension of faces in the source of the map</span>              </li>
              <li>
<span><tt>Delta</tt>, <span>an <a title="the class of all abstract simplicial complexes" href="___Simplicial__Complex.html">abstract simplicial complex</a></span>, </span>              </li>
            </ul>
          </li>
          <li>
<a href="../../Macaulay2Doc/html/_using_spfunctions_spwith_spoptional_spinputs.html">Optional inputs</a>:            <ul>
              <li>
<span><tt>Labels</tt><tt> => </tt><span>a <a title="the class of all lists -- {...}" href="../../Macaulay2Doc/html/___List.html">list</a></span>, <span>default value {}</span>, of monomials in a polynomial ring, one for each vertex of $\Delta$</span>              </li>
            </ul>
          </li>
          <li>
Outputs:            <ul>
              <li>
<span><span>a <a title="the class of all matrices" href="../../Macaulay2Doc/html/___Matrix.html">matrix</a></span>, that determines a map from $i$-faces to $i-1$-faces of $\Delta$</span>              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div>
        <h2>Description</h2>
        <div>
          <p>Up to sign, the boundary maps form the differential in the chain complex associated to an abstract simplicial complex.  The columns of the output matrix are indexed by the $i$-faces of the abstract simplicial complex $\Delta$ and the rows are indexed by the $(i-1)$-faces.  The order of these indices is obtained from the <a title="get the $i$-faces of an abstract simplicial complex" href="_faces_lp__Z__Z_cm__Simplicial__Complex_rp.html">faces</a> method which is implicitly determined by the monomial order on the <a title="get the polynomial ring of its Stanley–Reisner ideal" href="_ring_lp__Simplicial__Complex_rp.html">underlying ring</a>.  The matrix is defined over the <a title="get the coefficient ring of the underlying polynomial ring" href="_coefficient__Ring_lp__Simplicial__Complex_rp.html">coefficient ring</a> of $\Delta$ and its entries in this matrix are $-1$, $0$,or $1$ depending on whether the row index is an oriented face of the column index.  The orientation of $\Delta$ is induced by the ordering of the variables in its underlying ring.</p>
        </div>
        <div>
          <p>Working over the integers, we have the boundary maps for the standard $3$-simplex.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i1 : R = ZZ[a..d];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i2 : Δ = simplicialComplex {a*b*c*d}

o2 = simplicialComplex | abcd |

o2 : SimplicialComplex</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i3 : boundaryMap(0, Δ)

o3 = | 1 1 1 1 |

              1        4
o3 : Matrix ZZ  &lt;--- ZZ</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i4 : boundaryMap(1, Δ)

o4 = | -1 -1 -1 0  0  0  |
     | 1  0  0  -1 -1 0  |
     | 0  1  0  1  0  -1 |
     | 0  0  1  0  1  1  |

              4        6
o4 : Matrix ZZ  &lt;--- ZZ</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i5 : boundaryMap(2, Δ)

o5 = | 1  1  0  0  |
     | -1 0  1  0  |
     | 0  -1 -1 0  |
     | 1  0  0  1  |
     | 0  1  0  -1 |
     | 0  0  1  1  |

              6        4
o5 : Matrix ZZ  &lt;--- ZZ</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i6 : boundaryMap(3, Δ)

o6 = | -1 |
     | 1  |
     | -1 |
     | 1  |

              4        1
o6 : Matrix ZZ  &lt;--- ZZ</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i7 : fVector Δ

o7 = {1, 4, 6, 4, 1}

o7 : List</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i8 : C = chainComplex Δ

       1       4       6       4       1
o8 = ZZ  &lt;-- ZZ  &lt;-- ZZ  &lt;-- ZZ  &lt;-- ZZ
                                      
     -1      0       1       2       3

o8 : ChainComplex</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i9 : assert all(4, i -> C.dd_i == - boundaryMap(i, Δ))</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>The boundary maps may depend on the coefficient ring.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i10 : R' = ZZ/2[a..d];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i11 : Δ' = sub(Δ, R');</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i12 : boundaryMap(0, Δ')

o12 = | 1 1 1 1 |

              ZZ 1       ZZ 4
o12 : Matrix (--)  &lt;--- (--)
               2          2</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i13 : boundaryMap(1, Δ')

o13 = | 1 1 1 0 0 0 |
      | 1 0 0 1 1 0 |
      | 0 1 0 1 0 1 |
      | 0 0 1 0 1 1 |

              ZZ 4       ZZ 6
o13 : Matrix (--)  &lt;--- (--)
               2          2</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i14 : boundaryMap(2, Δ')

o14 = | 1 1 0 0 |
      | 1 0 1 0 |
      | 0 1 1 0 |
      | 1 0 0 1 |
      | 0 1 0 1 |
      | 0 0 1 1 |

              ZZ 6       ZZ 4
o14 : Matrix (--)  &lt;--- (--)
               2          2</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i15 : boundaryMap(3, Δ')

o15 = | 1 |
      | 1 |
      | 1 |
      | 1 |

              ZZ 4       ZZ 1
o15 : Matrix (--)  &lt;--- (--)
               2          2</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>When the optional argument <tt>Labels</tt> is given a list of monomials, corresponding to the vertices of $\Delta$, this method returns the differential in a chain complex of free modules.  Each face, or basis vector, is labelled by the least common multiple of the labels on its vertices.  In other words, the chain complex associated to a labelled simplicial complex is the <em>homogenization</em> of the canonical chain complex associated to $\Delta$; see Chapter 4 in Miller-Sturmfels' <em>Combinatorial Commutative Algebra</em> or Section 55 in Irena Peeva's <em>Graded Syzygies</em>.</p>
        </div>
        <div>
          <p>Labelling the vertices in the standard $3$-simplex by its unique monomial generators, we obtain the differential in the Taylor resolution of a monomial ideal.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i16 : S = ZZ/101[x_0, x_1];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i17 : M = monomialIdeal(x_1^3, x_0*x_1^2, x_0^2*x_1, x_0^3);

o17 : MonomialIdeal of S</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i18 : boundaryMap(0, Δ,  Labels => sort M_*)

o18 = | x_1^3 x_0x_1^2 x_0^2x_1 x_0^3 |

              1       4
o18 : Matrix S  &lt;--- S</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i19 : boundaryMap(1, Δ,  Labels => sort M_*)

o19 = {3} | -x_0 -x_0^2 -x_0^3 0    0      0    |
      {3} | x_1  0      0      -x_0 -x_0^2 0    |
      {3} | 0    x_1^2  0      x_1  0      -x_0 |
      {3} | 0    0      x_1^3  0    x_1^2  x_1  |

              4       6
o19 : Matrix S  &lt;--- S</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i20 : boundaryMap(2, Δ,  Labels => sort M_*)

o20 = {4} | x_0 x_0^2 0     0   |
      {5} | -1  0     x_0   0   |
      {6} | 0   -1    -1    0   |
      {4} | x_1 0     0     x_0 |
      {5} | 0   x_1   0     -1  |
      {4} | 0   0     x_1^2 x_1 |

              6       4
o20 : Matrix S  &lt;--- S</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i21 : boundaryMap(3, Δ,  Labels => sort M_*)

o21 = {5} | -x_0 |
      {6} | 1    |
      {6} | -1   |
      {5} | x_1  |

              4       1
o21 : Matrix S  &lt;--- S</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i22 : T = taylorResolution M

       1      4      6      4      1
o22 = S  &lt;-- S  &lt;-- S  &lt;-- S  &lt;-- S
                                   
      0      1      2      3      4

o22 : ChainComplex</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i23 : T.dd

           1                                         4
o23 = 0 : S  &lt;------------------------------------- S  : 1
                | x_1^3 x_0x_1^2 x_0^2x_1 x_0^3 |

           4                                                   6
      1 : S  &lt;----------------------------------------------- S  : 2
                {3} | -x_0 -x_0^2 -x_0^3 0    0      0    |
                {3} | x_1  0      0      -x_0 -x_0^2 0    |
                {3} | 0    x_1^2  0      x_1  0      -x_0 |
                {3} | 0    0      x_1^3  0    x_1^2  x_1  |

           6                                   4
      2 : S  &lt;------------------------------- S  : 3
                {4} | x_0 x_0^2 0     0   |
                {5} | -1  0     x_0   0   |
                {6} | 0   -1    -1    0   |
                {4} | x_1 0     0     x_0 |
                {5} | 0   x_1   0     -1  |
                {4} | 0   0     x_1^2 x_1 |

           4                    1
      3 : S  &lt;---------------- S  : 4
                {5} | -x_0 |
                {6} | 1    |
                {6} | -1   |
                {5} | x_1  |

o23 : ChainComplexMap</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i24 : assert all(4, i -> T.dd_(i+1) == boundaryMap(i, Δ,  Labels => sort M_*))</code></pre>
</td>          </tr>
        </table>
      </div>
      <div>
        <h2>See also</h2>
        <ul>
          <li>
<span><a title="information about the chain complexes and their homogenizations" href="___Working_spwith_spassociated_spchain_spcomplexes.html">Working with associated chain complexes</a> -- information about the chain complexes and their homogenizations</span>          </li>
          <li>
<span><a title="create the chain complex associated to a simplicial complex." href="_chain__Complex_lp__Simplicial__Complex_rp.html">chainComplex(SimplicialComplex)</a> -- create the chain complex associated to a simplicial complex.</span>          </li>
          <li>
<span><a title="create the Taylor resolution of a monomial ideal" href="_taylor__Resolution.html">taylorResolution(MonomialIdeal)</a> -- create the Taylor resolution of a monomial ideal</span>          </li>
        </ul>
      </div>
      <div class="waystouse">
        <h2>Ways to use this method:</h2>
        <ul>
          <li>
<span><a title="make a boundary map between the oriented faces of an abstract simplicial complex" href="_boundary__Map_lp__Z__Z_cm__Simplicial__Complex_rp.html">boundaryMap(ZZ,SimplicialComplex)</a> -- make a boundary map between the oriented faces of an abstract simplicial complex</span>          </li>
        </ul>
      </div>
    </div>
  </body>

</html>
