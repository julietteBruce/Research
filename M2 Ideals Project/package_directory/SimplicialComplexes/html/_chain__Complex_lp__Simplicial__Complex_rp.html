<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>chainComplex(SimplicialComplex) -- create the chain complex associated to a simplicial complex.</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <link type="text/css" rel="stylesheet" href="../../../../Macaulay2/Style/doc.css"/>

    <link rel="stylesheet" href="../../../../Macaulay2/Style/katex/katex.min.css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/katex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/auto-render.min.js"></script>
    <script defer="defer" type="text/javascript">
      var macros = {
          "\\break": "\\\\",
          "\\ZZ": "\\mathbb{Z}",
          "\\NN": "\\mathbb{N}",
          "\\QQ": "\\mathbb{Q}",
          "\\RR": "\\mathbb{R}",
          "\\CC": "\\mathbb{C}",
          "\\PP": "\\mathbb{P}"
      }, delimiters = [
          { left: "$$",  right: "$$",  display: true},
          { left: "\\[", right: "\\]", display: true},
          { left: "$",   right: "$",   display: false},
          { left: "\\(", right: "\\)", display: false}
      ], ignoredTags = ["tt", "script", "noscript", "style", "textarea", "pre", "code", "option"];
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, { delimiters: delimiters, macros: macros, ignoredTags: ignoredTags, trust: true });
      });
    </script>
    <style type="text/css">.katex { font-size: 1em; }</style>
    <link href="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.css" rel="stylesheet" type="text/css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/render-a11y-string.min.js"></script>
    <script type="text/javascript" src="../../../../Macaulay2/Style/highlight.js"></script>
  </head>
  <body>
    <table class="buttons">
      <tr>
<td>          <div>
<a href="_chain__Complex_lp__Simplicial__Map_rp.html">next</a> | <a href="_buchberger__Simplicial__Complex.html">previous</a> | <a href="_chain__Complex_lp__Simplicial__Map_rp.html">forward</a> | <a href="_buchberger__Simplicial__Complex.html">backward</a> | up | <a href="index.html">top</a> | <a href="master.html">index</a> | <a href="toc.html">toc</a> | <a href="http://macaulay2.com/">Macaulay2 website</a>          </div>
</td>      </tr>
    </table>
    <div>
<a title="exploring abstract simplicial complexes within commutative algebra" href="index.html">SimplicialComplexes</a> :: <a title="create the chain complex associated to a simplicial complex." href="_chain__Complex_lp__Simplicial__Complex_rp.html">chainComplex(SimplicialComplex)</a>    </div>
    <hr/>
    <div>
      <h1>chainComplex(SimplicialComplex) -- create the chain complex associated to a simplicial complex.</h1>
      <div>
        <h2>Synopsis</h2>
        <ul>
          <li>
<span>Function: <a title="make a chain complex" href="../../Macaulay2Doc/html/_chain__Complex.html">chainComplex</a></span>          </li>
          <li>
            <dl class="element">
              <dt>Usage: </dt>
              <dd><code class="language-macaulay2">chainComplex Delta</code></dd>
              <dd><code class="language-macaulay2">chainComplex(Delta, Labels => L)</code></dd>
            </dl>
          </li>
          <li>
Inputs:            <ul>
              <li>
<span><tt>Delta</tt>, <span>an <a title="the class of all abstract simplicial complexes" href="___Simplicial__Complex.html">abstract simplicial complex</a></span>, </span>              </li>
            </ul>
          </li>
          <li>
<a href="../../Macaulay2Doc/html/_using_spfunctions_spwith_spoptional_spinputs.html">Optional inputs</a>:            <ul>
              <li>
<span><tt>Labels</tt><tt> => </tt><span>a <a title="the class of all lists -- {...}" href="../../Macaulay2Doc/html/___List.html">list</a></span>, <span>default value {}</span>, L of monomials in a polynomial ring, one for each vertex of $\Delta$</span>              </li>
            </ul>
          </li>
          <li>
Outputs:            <ul>
              <li>
<span><tt>C</tt>, <span>a <a title="the class of all chain complexes" href="../../Macaulay2Doc/html/___Chain__Complex.html">chain complex</a></span>, of free modules</span>              </li>
            </ul>
          </li>
        </ul>
      </div>
      <div>
        <h2>Description</h2>
        <div>
          <p>Each abstract simplicial complex $\Delta$ determines a chain complex of free modules over its <a title="get the coefficient ring of the underlying polynomial ring" href="_coefficient__Ring_lp__Simplicial__Complex_rp.html">coefficient ring</a>.  For all integers $i$, the $i$-th module in this chain complex has a basis corresponding to the $i$-dimensional faces in the simplicial complex $\Delta$.</p>
        </div>
        <div>
          <p>When the argument $\mathrm{Labels}$ has the default value, this method function constructs $\widetilde C(D;k)$, where $k$ is the <a title="get the coefficient ring of the underlying polynomial ring" href="_coefficient__Ring_lp__Simplicial__Complex_rp.html">coefficient ring</a> of $\Delta$. The <em>reduced homology</em> of an abstract simplicial complex $\Delta$ is, by definition, the homology of this chain complex.  We illustrate this method with a triangulation of the torus and Klein bottle.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i1 : S = QQ[a..g];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i2 : torus = smallManifold(2, 7, 6, S)

o2 = simplicialComplex | cfg afg beg aeg cdg bdg def bef adf bcf cde ace abd abc |

o2 : SimplicialComplex</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i3 : C = chainComplex torus

       1       7       21       14
o3 = QQ  &lt;-- QQ  &lt;-- QQ   &lt;-- QQ
                               
     -1      0       1        2

o3 : ChainComplex</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i4 : fVector torus

o4 = {1, 7, 21, 14}

o4 : List</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i5 : prune HH C

o5 = -1 : 0  

      0 : 0  

            2
      1 : QQ

            1
      2 : QQ

o5 : GradedModule</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i6 : assert(prune HH_1 C == QQ^2)</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i7 : assert(prune HH_2 C == QQ^1)</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i8 : prune HH torus

o8 = -1 : 0  

      0 : 0  

            2
      1 : QQ

            1
      2 : QQ

o8 : GradedModule</code></pre>
</td>          </tr>
        </table>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i9 : R = ZZ[a..h];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i10 : Δ = kleinBottleComplex R

o10 = simplicialComplex | cgh agh cfh afh efg dfg aeg cdg bef adf bcf cde bde ace abd abc |

o10 : SimplicialComplex</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i11 : C' = chainComplex Δ

        1       8       24       16
o11 = ZZ  &lt;-- ZZ  &lt;-- ZZ   &lt;-- ZZ
                                
      -1      0       1        2

o11 : ChainComplex</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i12 : C'.dd

             1                                    8
o12 = -1 : ZZ  &lt;------------------------------- ZZ  : 0
                  | -1 -1 -1 -1 -1 -1 -1 -1 |

            8                                                                                    24
      0 : ZZ  &lt;------------------------------------------------------------------------------- ZZ   : 1
                 | 1  1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  |
                 | -1 0  0  0  0  0  0  1  1  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  |
                 | 0  -1 0  0  0  0  0  -1 0  0  0  1  1  1  1  1  0  0  0  0  0  0  0  0  |
                 | 0  0  -1 0  0  0  0  0  -1 0  0  -1 0  0  0  0  1  1  1  0  0  0  0  0  |
                 | 0  0  0  -1 0  0  0  0  0  -1 0  0  -1 0  0  0  -1 0  0  1  1  0  0  0  |
                 | 0  0  0  0  -1 0  0  0  0  0  -1 0  0  -1 0  0  0  -1 0  -1 0  1  1  0  |
                 | 0  0  0  0  0  -1 0  0  0  0  0  0  0  0  -1 0  0  0  -1 0  -1 -1 0  1  |
                 | 0  0  0  0  0  0  -1 0  0  0  0  0  0  0  0  -1 0  0  0  0  0  0  -1 -1 |

            24                                                            16
      1 : ZZ   &lt;------------------------------------------------------- ZZ   : 2
                  | -1 -1 0  0  0  0  0  0  0  0  0  0  0  0  0  0  |
                  | 1  0  -1 0  0  0  0  0  0  0  0  0  0  0  0  0  |
                  | 0  1  0  -1 0  0  0  0  0  0  0  0  0  0  0  0  |
                  | 0  0  1  0  -1 0  0  0  0  0  0  0  0  0  0  0  |
                  | 0  0  0  1  0  -1 0  0  0  0  0  0  0  0  0  0  |
                  | 0  0  0  0  1  0  -1 0  0  0  0  0  0  0  0  0  |
                  | 0  0  0  0  0  1  1  0  0  0  0  0  0  0  0  0  |
                  | -1 0  0  0  0  0  0  -1 0  0  0  0  0  0  0  0  |
                  | 0  -1 0  0  0  0  0  0  -1 0  0  0  0  0  0  0  |
                  | 0  0  0  0  0  0  0  0  1  -1 0  0  0  0  0  0  |
                  | 0  0  0  0  0  0  0  1  0  1  0  0  0  0  0  0  |
                  | 0  0  0  0  0  0  0  0  0  0  -1 -1 0  0  0  0  |
                  | 0  0  -1 0  0  0  0  0  0  0  1  0  0  0  0  0  |
                  | 0  0  0  0  0  0  0  -1 0  0  0  0  -1 0  0  0  |
                  | 0  0  0  0  0  0  0  0  0  0  0  1  0  -1 0  0  |
                  | 0  0  0  0  0  0  0  0  0  0  0  0  1  1  0  0  |
                  | 0  0  0  0  0  0  0  0  -1 0  -1 0  0  0  0  0  |
                  | 0  0  0  -1 0  0  0  0  0  0  0  0  0  0  -1 0  |
                  | 0  0  0  0  0  0  0  0  0  0  0  -1 0  0  1  0  |
                  | 0  0  0  0  0  0  0  0  0  -1 0  0  0  0  0  -1 |
                  | 0  0  0  0  -1 0  0  0  0  0  0  0  0  0  0  1  |
                  | 0  0  0  0  0  0  0  0  0  0  0  0  0  0  -1 -1 |
                  | 0  0  0  0  0  -1 0  0  0  0  0  0  -1 0  0  0  |
                  | 0  0  0  0  0  0  -1 0  0  0  0  0  0  -1 0  0  |

o12 : ChainComplexMap</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i13 : fVector Δ

o13 = {1, 8, 24, 16}

o13 : List</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i14 : prune HH C'

o14 = -1 : 0             

       0 : 0             

       1 : cokernel | 2 |
                    | 0 |

       2 : 0             

o14 : GradedModule</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i15 : prune HH Δ

o15 = -1 : 0             

       0 : 0             

       1 : cokernel | 2 |
                    | 0 |

       2 : 0             

o15 : GradedModule</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i16 : assert(prune HH_1 C' == ZZ^1/ideal(2) ++ ZZ^1)</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>When the optional argument $\mathrm{Labels}$ is a list of monomials, corresponding to the vertices of $\Delta$, this method returns a chain complex of free modules over the ring containing monomial labels.  Each face, or basis vector, is labelled by the least common multiple of the labels on its vertices. In other words, the chain complex associated to a labelled simplicial complex is the <em>homogenization</em> of the canonical chain complex associated to $\Delta$; see Chapter 4 in Miller-Sturmfels' <em>Combinatorial Commutative Algebra</em> or Section 55 in Irena Peeva's <em>Graded Syzygies</em>.</p>
        </div>
        <div>
          <p>As the next example establishes, this approach can sometimes produce a minimal free resolution of a monomial ideal.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i17 : S = QQ[a..d];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i18 : Γ = simplicialComplex{a*b*c, b*c*d};</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i19 : C = chainComplex Γ

        1       4       5       2
o19 = QQ  &lt;-- QQ  &lt;-- QQ  &lt;-- QQ
                               
      -1      0       1       2

o19 : ChainComplex</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i20 : C.dd

             1                        4
o20 = -1 : QQ  &lt;------------------- QQ  : 0
                  | -1 -1 -1 -1 |

            4                           5
      0 : QQ  &lt;---------------------- QQ  : 1
                 | 1  1  0  0  0  |
                 | -1 0  1  1  0  |
                 | 0  -1 -1 0  1  |
                 | 0  0  0  -1 -1 |

            5                  2
      1 : QQ  &lt;------------- QQ  : 2
                 | -1 0  |
                 | 1  0  |
                 | -1 -1 |
                 | 0  1  |
                 | 0  -1 |

o20 : ChainComplexMap</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i21 : R = QQ[x_0..x_3];</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i22 : hC = chainComplex(Γ, Labels => {x_0*x_1, x_3, x_1*x_2, x_0*x_2})

       1      4      5      2
o22 = R  &lt;-- R  &lt;-- R  &lt;-- R
                            
      0      1      2      3

o22 : ChainComplex</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i23 : hC.dd

           1                                    4
o23 = 0 : R  &lt;-------------------------------- R  : 1
                | x_0x_1 x_3 x_1x_2 x_0x_2 |

           4                                                5
      1 : R  &lt;-------------------------------------------- R  : 2
                {2} | -x_3   -x_2 0       0       0    |
                {1} | x_0x_1 0    -x_1x_2 -x_0x_2 0    |
                {2} | 0      x_0  x_3     0       -x_0 |
                {2} | 0      0    0       x_3     x_1  |

           5                         2
      2 : R  &lt;--------------------- R  : 3
                {3} | x_2  0    |
                {3} | -x_3 0    |
                {3} | x_0  x_0  |
                {3} | 0    -x_1 |
                {3} | 0    x_3  |

o23 : ChainComplexMap</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i24 : prune homology hC

o24 = 0 : cokernel | x_3 x_1x_2 x_0x_2 x_0x_1 |

      1 : 0                                    

      2 : 0                                    

      3 : 0                                    

o24 : GradedModule</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>By convention, the smallest nonzero term in the homogenized chain complex appears in homological degree $0$, rather than homological degree $-1$.  This shift in homological degree changes the signs in the differentials.</p>
        </div>
        <div>
          <p>The homogenization of the chain complex associated to an abstract simplicial complex does not always produce a free resolution. Reordering the labels in the previous example demonstrates this.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i25 : hC' = chainComplex(Γ, Labels => {x_3, x_0*x_1, x_1*x_2, x_0*x_2})

       1      4      5      2
o25 = R  &lt;-- R  &lt;-- R  &lt;-- R
                            
      0      1      2      3

o25 : ChainComplex</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i26 : hC'.dd

           1                                    4
o26 = 0 : R  &lt;-------------------------------- R  : 1
                | x_3 x_0x_1 x_1x_2 x_0x_2 |

           4                                              5
      1 : R  &lt;------------------------------------------ R  : 2
                {1} | -x_0x_1 -x_1x_2 0    0    0    |
                {2} | x_3     0       -x_2 -x_2 0    |
                {2} | 0       x_3     x_0  0    -x_0 |
                {2} | 0       0       0    x_1  x_1  |

           5                       2
      2 : R  &lt;------------------- R  : 3
                {3} | x_2  0  |
                {3} | -x_0 0  |
                {3} | x_3  1  |
                {3} | 0    -1 |
                {3} | 0    1  |

o26 : ChainComplexMap</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i27 : prune HH hC'

o27 = 0 : cokernel | x_3 x_1x_2 x_0x_2 x_0x_1 |

      1 : cokernel {3} | x_1 |                 

      2 : 0                                    

      3 : 0                                    

o27 : GradedModule</code></pre>
</td>          </tr>
        </table>
      </div>
      <div>
        <h2>See also</h2>
        <ul>
          <li>
<span><a title="information about the chain complexes and their homogenizations" href="___Working_spwith_spassociated_spchain_spcomplexes.html">Working with associated chain complexes</a> -- information about the chain complexes and their homogenizations</span>          </li>
          <li>
<span><a title="get the coefficient ring of the underlying polynomial ring" href="_coefficient__Ring_lp__Simplicial__Complex_rp.html">coefficientRing(SimplicialComplex)</a> -- get the coefficient ring of the underlying polynomial ring</span>          </li>
          <li>
<span><a title="make a boundary map between the oriented faces of an abstract simplicial complex" href="_boundary__Map_lp__Z__Z_cm__Simplicial__Complex_rp.html">boundaryMap(ZZ,SimplicialComplex)</a> -- make a boundary map between the oriented faces of an abstract simplicial complex</span>          </li>
          <li>
<span><a title="compute a projective resolution of (the quotient ring corresponding to) an ideal" href="../../Macaulay2Doc/html/_resolution_lp__Ideal_rp.html">resolution(Ideal)</a> -- compute a projective resolution of (the quotient ring corresponding to) an ideal</span>          </li>
          <li>
<span><a title="homology of a chain complex" href="../../Macaulay2Doc/html/___H__H_sp__Chain__Complex.html">HH ChainComplex</a> -- homology of a chain complex</span>          </li>
        </ul>
      </div>
      <div class="waystouse">
        <h2>Ways to use this method:</h2>
        <ul>
          <li>
<span><a title="create the chain complex associated to a simplicial complex." href="_chain__Complex_lp__Simplicial__Complex_rp.html">chainComplex(SimplicialComplex)</a> -- create the chain complex associated to a simplicial complex.</span>          </li>
        </ul>
      </div>
    </div>
  </body>

</html>
