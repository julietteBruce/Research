<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>Basic operations on noncommutative algebras</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
    <link type="text/css" rel="stylesheet" href="../../../../Macaulay2/Style/doc.css"/>

    <link rel="stylesheet" href="../../../../Macaulay2/Style/katex/katex.min.css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/katex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/auto-render.min.js"></script>
    <script defer="defer" type="text/javascript">
      var macros = {
          "\\break": "\\\\",
          "\\ZZ": "\\mathbb{Z}",
          "\\NN": "\\mathbb{N}",
          "\\QQ": "\\mathbb{Q}",
          "\\RR": "\\mathbb{R}",
          "\\CC": "\\mathbb{C}",
          "\\PP": "\\mathbb{P}"
      }, delimiters = [
          { left: "$$",  right: "$$",  display: true},
          { left: "\\[", right: "\\]", display: true},
          { left: "$",   right: "$",   display: false},
          { left: "\\(", right: "\\)", display: false}
      ], ignoredTags = ["tt", "script", "noscript", "style", "textarea", "pre", "code", "option"];
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, { delimiters: delimiters, macros: macros, ignoredTags: ignoredTags, trust: true });
      });
    </script>
    <style type="text/css">.katex { font-size: 1em; }</style>
    <link href="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.css" rel="stylesheet" type="text/css" />
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/copy-tex.min.js"></script>
    <script defer="defer" type="text/javascript" src="../../../../Macaulay2/Style/katex/contrib/render-a11y-string.min.js"></script>
    <script type="text/javascript" src="../../../../Macaulay2/Style/highlight.js"></script>
  </head>
  <body>
    <table class="buttons">
      <tr>
<td>          <div>
<a href="___General_spsetup_spinformation.html">next</a> | previous | <a href="___General_spsetup_spinformation.html">forward</a> | <a href="index.html">backward</a> | <a href="index.html">up</a> | <a href="index.html">top</a> | <a href="master.html">index</a> | <a href="toc.html">toc</a> | <a href="http://macaulay2.com/">Macaulay2 website</a>          </div>
</td>      </tr>
    </table>
    <div>
<a href="index.html">NCAlgebra</a> > <a href="___Basic_spoperations_spon_spnoncommutative_spalgebras.html">Basic operations on noncommutative algebras</a>    </div>
    <hr/>
    <div>
      <h1>Basic operations on noncommutative algebras</h1>
      <div>
        <div>
          <p>The NCAlgebra package contains a number of methods for studying noncommutative rings - primarily graded rings. The following three extended examples highlight the capabilities of the package. For a detailed account of the Groebner basis calculations underlying nearly all of these methods, see <a href="___Using_spthe_sp__Bergman_spinterface.html">Using the Bergman interface</a>.</p>
        </div>
        <div>
          <p>Our first example concerns a three-dimensional Sklyanin algebra. This example is a PI-ring. We define the ring as a quotient of the tensor algebra on three generators by the two-sided ideal generated by the three elements listed.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i1 : A = QQ{x,y,z}

o1 = A

o1 : NCPolynomialRing</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Users familiar with Macaulay2 will recognize the notation for a ring of noncommutative polynomials is identical to that for local rings, see <a title="make a local polynomial ring" href="../../Macaulay2Doc/html/___Ring_sp__List.html">Ring List</a>. Thus the previous line does not generate an error if you forget to load the NCAlgebra package.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i2 : f = y*z + z*y - x^2

            2
o2 = zy+yz-x

o2 : A</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i3 : g = x*z + z*x - y^2

         2
o3 = zx-y +xz

o3 : A</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i4 : h = z^2 - x*y - y*x

      2
o4 = z -yx-xy

o4 : A</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i5 : B = A/ncIdeal{f,g,h}
--Calling Bergman for NCGB calculation.
Complete!

o5 = B

o5 : NCQuotientRing</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>It is known that this algebra has a unique (up to rescaling) central element of degree 3. We can verify this claim computationally using <a title="Finds central elements in a given degree" href="_central__Elements.html">centralElements</a> and check that the element is regular to a given degree. See <a title="Determines if a given (homogeneous) element is regular in a given degree" href="_is__Left__Regular.html">isLeftRegular</a>.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i6 : centralElements(B,3)

o6 = | y^3-y*x*z+x*y*z-x^3 |

o6 : NCMatrix</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i7 : j = y^3+x*y*z-y*x*z-x^3

      3          3
o7 = y -yxz+xyz-x

o7 : B</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i8 : isCentral j

o8 = true</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i9 : apply(5,i->isLeftRegular(j,i+1))

o9 = {true, true, true, true, true}

o9 : List</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>In fact, we can see that j is (up to scaling) the only normal element of degree 3. See the discussion above for interpreting the output of <a title="Finds normal elements" href="_normal__Elements.html">normalElements</a>.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i10 : normalElements(B,3,n,o)
Normal monomials of degree 3:
none
Components of the normal variety, excluding normal monomials:

o10 = {| n_(y^2*z) n_(y*x*z)+n_(x*y*z) n_(x^2*z) n_(y^3)-n_(x*y*z) n_(x*y^2)
      -----------------------------------------------------------------------
      n_(y*x*y) n_(x^2*y) n_(x*y*x) n_(x^3)+n_(x*y*z) |}

o10 : List</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i11 : basis(3,B)

o11 = | x^3 x*y*x x^2*y y*x*y x*y^2 y^3 x^2*z y*x*z x*y*z y^2*z |

o11 : NCMatrix</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Recently, we studied noncommutative matrix factorizations over noncommutative hypersurfaces. Here is a simple example. The hypersurface is B/(j). However, iterated quotients are not yet implemented, so we define this ring as a quotient of the tensor algebra. Note the use of &quot;promote&quot; to ensure j is thought of as an element of the tensor algebra.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i12 : use A

o12 = A

o12 : NCPolynomialRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i13 : I = B.ideal

                              2      2      2
o13 = Two-sided ideal {zy+yz-x , zx-y +xz, z -yx-xy}

o13 : NCIdeal</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i14 : J = ncIdeal promote(j,A)

                        3          3
o14 = Two-sided ideal {y -yxz+xyz-x }

o14 : NCIdeal</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i15 : B' = A/(I+J)
--Calling Bergman for NCGB calculation.
Complete!

o15 = B'

o15 : NCQuotientRing</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>As in the commutative case, any minimal free resolution of a finitely generated module over a noncommutative hypersurface is eventually given by a matrix factorization. We resolve the trivial module for B' by expressing it as the cokernel of a homogeneous matrix.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i16 : k = ncMatrix {gens B'}

o16 = | x y z |

o16 : NCMatrix</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i17 : M = rightKernelBergman rightKernelBergman k
--Calling Bergman for NCGB calculation.
Complete!
--Calling Bergman for NCGB calculation.
Complete!
--Calling Bergman for NCGB calculation.
Complete!
--Calling Bergman for NCGB calculation.
Complete!
--Calling Bergman for NCGB calculation.
Complete!
--Calling Bergman for NCGB calculation.
Complete!

o17 = | -z y*z     -y^2    -y*x-2*x*y |
      | x  y*x+x*y y*z+x^2 -y^2+3*x*z |
      | y  -x*z    -x*y    x^2        |
      | 0  -2*y    -2*x    -2*z       |

o17 : NCMatrix</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i18 : N = rightKernelBergman M
--Calling Bergman for NCGB calculation.
Complete!
--Calling Bergman for NCGB calculation.
Complete!

o18 = | 0  2*y*x 2*y^2-2*x*z -y*x*z-x^3 |
      | -z x     y           -y^2+x*z   |
      | x  y     -z          -y*z+x^2   |
      | -y -z    -x          0          |

o18 : NCMatrix</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>As discussed in <a href="___Using_spthe_sp__Bergman_spinterface.html">Using the Bergman interface</a>, the method <a title="Methods for computing kernels of matrices over noncommutative rings using Bergman" href="_right__Kernel__Bergman.html">rightKernelBergman</a> only computes the kernel of a module map to a certain homogeneous degree. Applying a theorem of Cassidy and Shelton, we can be sure the matrices in any minimal graded free resolution of the trivial module of B' will have entries of homogeneous degree at most 3. Thus we conclude M is the third syzygy module and N is the fourth. If we lift these matrices we see that M and N are nearly a factorization of the central element j.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i19 : BprimeToB = ncMap(B,B',gens B)

o19 = NCRingMap B &lt;--- B'

o19 : NCRingMap</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i20 : liftM = BprimeToB M

o20 = | -z y*z     -y^2    -y*x-2*x*y |
      | x  y*x+x*y y*z+x^2 -y^2+3*x*z |
      | y  -x*z    -x*y    x^2        |
      | 0  -2*y    -2*x    -2*z       |

o20 : NCMatrix</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i21 : liftN = BprimeToB N

o21 = | 0  2*y*x 2*y^2-2*x*z -y*x*z-x^3 |
      | -z x     y           -y^2+x*z   |
      | x  y     -z          -y*z+x^2   |
      | -y -z    -x          0          |

o21 : NCMatrix</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i22 : liftM*liftN

o22 = | 0                           2*y^3-2*y*x*z+2*x*y*z-2*x^3 0                           0                           |
      | 2*y^3-2*y*x*z+2*x*y*z-2*x^3 0                           0                           0                           |
      | 0                           0                           2*y^3-2*y*x*z+2*x*y*z-2*x^3 0                           |
      | 0                           0                           0                           2*y^3-2*y*x*z+2*x*y*z-2*x^3 |

o22 : NCMatrix</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>It appears that a change of basis will produce a matrix factorization. In general, Bergman returns a generating set for the kernel, but it need not have any nice properties. Here the NCAlgebra package can help by factoring a map. We would like M*M' = M'*M = j*I where I is the identity matrix.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i23 : jId = promote(j,B)*(ncMatrix applyTable(entries id_(ZZ^4), i -> promote(i,B)))

o23 = | y^3-y*x*z+x*y*z-x^3 0                   0                   0                   |
      | 0                   y^3-y*x*z+x*y*z-x^3 0                   0                   |
      | 0                   0                   y^3-y*x*z+x*y*z-x^3 0                   |
      | 0                   0                   0                   y^3-y*x*z+x*y*z-x^3 |

o23 : NCMatrix</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i24 : assignDegrees(jId,{2,2,2,3},{5,5,5,6});</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>The matrix jId is diagonal, and we have assigned degrees to make it compatible with M. Now we factor the lift of M through jId.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i25 : M' = jId // liftM
--Calling Bergman for NCGB calculation.
Complete!

o25 = | y*x    0      y^2-x*z -1/2*y*x*z-1/2*x^3 |
      | 1/2*x  -1/2*z 1/2*y   -1/2*y^2+1/2*x*z   |
      | 1/2*y  1/2*x  -1/2*z  -1/2*y*z+1/2*x^2   |
      | -1/2*z -1/2*y -1/2*x  0                  |

o25 : NCMatrix</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i26 : N

o26 = | 0  2*y*x 2*y^2-2*x*z -y*x*z-x^3 |
      | -z x     y           -y^2+x*z   |
      | x  y     -z          -y*z+x^2   |
      | -y -z    -x          0          |

o26 : NCMatrix</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>We see that M' and N describe the same submodule and we check that the factorization worked:</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i27 : liftM*M'

o27 = | y^3-y*x*z+x*y*z-x^3 0                   0                   0                   |
      | 0                   y^3-y*x*z+x*y*z-x^3 0                   0                   |
      | 0                   0                   y^3-y*x*z+x*y*z-x^3 0                   |
      | 0                   0                   0                   y^3-y*x*z+x*y*z-x^3 |

o27 : NCMatrix</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i28 : M'*liftM

o28 = | y^3-y*x*z+x*y*z-x^3 0                   0                   0                   |
      | 0                   y^3-y*x*z+x*y*z-x^3 0                   0                   |
      | 0                   0                   y^3-y*x*z+x*y*z-x^3 0                   |
      | 0                   0                   0                   y^3-y*x*z+x*y*z-x^3 |

o28 : NCMatrix</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>The user can create noncommutative rings in ways other than specifying a presentation. For our second example, consider a skew polynomial ring on four generators, where generators skew-commute (but are not nilpotent). See <a title="Defines a skew polynomial ring via a skewing matrix" href="_skew__Polynomial__Ring.html">skewPolynomialRing</a> for more details.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i29 : C = skewPolynomialRing(QQ,(-1)_QQ,{x,y,z,w})
--Calling Bergman for NCGB calculation.
Complete!

o29 = C

o29 : NCQuotientRing</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Let us briefly note that the user can also define a skew polynomial ring with coefficients in a commutative ring.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i30 : R = QQ[q]/ideal{q^4+q^3+q^2+q+1}

o30 = R

o30 : QuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i31 : B = skewPolynomialRing(R,q,{x,y,z,w})

o31 = B

o31 : NCQuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i32 : x*y == q*y*x

o32 = true</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Returning to the main example, we can define a graded Ore extension of C by specifying an automorphism. The function <a title="Make a map to or from an NCRing" href="_nc__Map.html">ncMap</a> is used to define a ring map. Note that ring maps are linear and multiplicative by definition but are not assumed to be  well-defined.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i33 : use C

o33 = C

o33 : NCQuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i34 : sigma = ncMap(C,C,{y,z,w,x})

o34 = NCRingMap C &lt;--- C

o34 : NCRingMap</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i35 : isWellDefined sigma

o35 = true</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>We form the Ore extension of C by sigma. See <a title="Creates an Ore extension of a noncommutative ring" href="_ore__Extension.html">oreExtension</a>.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i36 : D = oreExtension(C,sigma,a)
--Calling Bergman for NCGB calculation.
Complete!

o36 = D

o36 : NCQuotientRing</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>The new generator a is normal and regular in D. Regularity (on the left or right) can be checked one homogeneous degree at a time. See <a title="Determines if a given (homogeneous) element is regular in a given degree" href="_is__Left__Regular.html">isLeftRegular</a>. Thus a determines a graded automorphism f:D->D via a*r=f(r)*a.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i37 : isNormal a

o37 = true</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i38 : apply(5,i-> isLeftRegular(a,i+1))

o38 = {true, true, true, true, true}

o38 : List</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i39 : sigmaD = normalAutomorphism a

o39 = NCRingMap D &lt;--- D

o39 : NCRingMap</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Given an automorphism, one can check to see which elements it normalizes in any given degree.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i40 : normalElements(sigmaD,1)

o40 = | a |

o40 : NCMatrix</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i41 : normalElements(sigmaD,2)

o41 = 0

               1
o41 : Matrix QQ  &lt;--- 0</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>One can check for the presence of normal elements more generally. In our example, since a is normal, a^2 will also be normal. It is the only normal monomial of degree 2. A complete description of the normal elements in a given degree is given by <a title="Finds normal elements" href="_normal__Elements.html">normalElements</a>.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i42 : normalElements(D,2,P,Q)
Normal monomials of degree 2:
 2
a
Components of the normal variety, excluding normal monomials:

o42 = {| P_(w*a) P_(z*a) P_(y*a) P_(x*a) P_(z*w) P_(y*w) P_(x*w) P_(y*z)
      -----------------------------------------------------------------------
      P_(x*z) P_(x*y) P_(z^2)^2-P_(y^2)P_(w^2) P_(y^2)P_(z^2)-P_(x^2)P_(w^2)
      -----------------------------------------------------------------------
      P_(x^2)P_(z^2)-P_(w^2)^2 P_(y^2)^2-P_(w^2)^2
      -----------------------------------------------------------------------
      P_(x^2)P_(y^2)-P_(z^2)P_(w^2) P_(x^2)^2-P_(y^2)P_(w^2) |}

o42 : List</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Each component of the &quot;normal variety&quot; is a set of polynomial equations which must be satisfied by the coefficients of the monomial basis for an element expressed in that basis to be normal. In this case, the basis of D in degree 2 is</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i43 : basis(2,D)

o43 = | x^2 x*y y^2 x*z y*z z^2 x*w y*w z*w w^2 x*a y*a z*a w*a a^2 |

o43 : NCMatrix</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>The output of normalElements tells us that in order for a degree 2 element of D to be normal, it must be an expression in powers of the generators. The coefficients of these powers must satisfy the six equations listed.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i44 : isNormal (x^2+z^2-y^2-w^2)

o44 = true</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>In Macaulay2, the user can define a polynomial ring to be commutative or skew-commutative (the exterior algebra). The user can convert these rings (and their quotients) to a type compatible with the NCAlgebra package using <a title="Converts a Ring to an NCRing" href="_to__N__C__Ring.html">toNCRing</a>.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i45 : E' = QQ[x,y,z,w,SkewCommutative=>true]

o45 = E'

o45 : PolynomialRing, 4 skew commutative variables</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i46 : E = toNCRing E'
--Calling Bergman for NCGB calculation.
Complete!

o46 = E

o46 : NCQuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i47 : f = ncMap(E,C,gens E)

o47 = NCRingMap E &lt;--- C

o47 : NCRingMap</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i48 : f x^2

o48 = 0

o48 : E</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i49 : use C

o49 = C

o49 : NCQuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i50 : x^2 == 0

o50 = false</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Conversely, the user can convert an NCRing to a (quotient of a) polynomial ring in the usual sense of Macaulay2 using <a title="Compute the abelianization of an NCRing and returns a Ring." href="_to__M2__Ring.html">toM2Ring</a>. This method works on any NCRing - the result is the abelianization or &quot;exterior-ization&quot; of the given ring. For example, if we abelianize the skew polynomial ring C, we get a ring in which only powers of the generators are nonzero. On the other hand, if we &quot;exterior-ize&quot; C, we get the exterior algebra.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i51 : C' = toM2Ring C

o51 = C'

o51 : QuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i52 : x*y

o52 = 0

o52 : C'</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i53 : x*x

       2
o53 = x

o53 : C'</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i54 : C'' = toM2Ring(C,SkewCommutative=>true)

o54 = C''

o54 : PolynomialRing, 4 skew commutative variables</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i55 : y*x

o55 = -x*y

o55 : C''</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i56 : y*y

o56 = 0

o56 : C''</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Finally, we can construct the opposite ring. The opposite ring of D will be the Ore extension by the inverse of sigma. See <a title="Creates the opposite ring of a noncommutative ring" href="_opposite__Ring.html">oppositeRing</a>.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i57 : Dop = oppositeRing D
--Calling Bergman for NCGB calculation.
Complete!

o57 = Dop

o57 : NCQuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i58 : a*x == w*a

o58 = true</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i59 : use D

o59 = D

o59 : NCQuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i60 : a*w == x*a

o60 = true</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>Our last extended example illustrates how to obtain a presentation for the endomorphism ring of a module over a commutative ring. First we define a hypersurface ring and a high syzygy module.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i61 : Q = QQ[a,b,c]

o61 = Q

o61 : PolynomialRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i62 : R = Q/ideal{a*b-c^2}

o62 = R

o62 : QuotientRing</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i63 : kRes = res(coker vars R, LengthLimit=>7);</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i64 : M = coker kRes.dd_5

o64 = cokernel {4} | 0  -a 0  -c |
               {4} | -b 0  -c 0  |
               {4} | c  0  a  0  |
               {4} | 0  c  0  b  |

                             4
o64 : R-module, quotient of R</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>The endomorphism ring is computed using <a title="Methods for creating endomorphism rings of modules over a commutative ring" href="_endomorphism__Ring.html">endomorphismRing</a>. This method computes a presentation, but the presentation is typically not minimal. We see from the following calculation that X_3 = X_0X_2.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i65 : B = endomorphismRing(M,X);</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i66 : gensI = gens ideal B

                                                                          
o66 = {X X +-X , -X +X X , -X +X X , X X , X X , X X +-X , X X , X X +-X ,
        0 1   0    3  0 2    2  1 2   0 3   1 3   2 3   2   1 0   2 0   1 
      -----------------------------------------------------------------------
                                    2    2        2    2
      X X , X X +-X , X X , X X , X  , X  +-X , X  , X  +-X }
       2 1   3 0   0   3 1   3 2   0    1    1   2    3    3

o66 : List</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>To eliminate redundant generators and relations, use <a title="Minimizes a list of NCRingElements" href="_minimize__Relations.html">minimizeRelations</a>. This method makes several passes through the presentation, and stops if no minimization occurs.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i67 : gensIMin = minimizeRelations(gensI, Verbosity=>1)
Eliminating variable X
                      1
Eliminating variable X
                      3
Reducing X_0*X_2*X_0+-X_0
  (1 of 12)
  (Pass 1)
Reducing X_2*X_0*X_2+-X_2
  (2 of 12)
  (Pass 1)
Reducing X_0^2*X_2
  (3 of 12)
  (Pass 1)
Reducing X_2*X_0^2*X_2
  (4 of 12)
  (Pass 1)
Reducing X_2*X_0^2
  (5 of 12)
  (Pass 1)
Reducing X_2^2*X_0
  (6 of 12)
  (Pass 1)
Reducing X_0*X_2^2*X_0
  (7 of 12)
  (Pass 1)
Reducing X_0*X_2^2
  (8 of 12)
  (Pass 1)
Reducing X_0^2
  (9 of 12)
  (Pass 1)
Reducing X_2*X_0*X_2*X_0+-X_2*X_0
  (10 of 12)
  (Pass 1)
Reducing X_2^2
  (11 of 12)
  (Pass 1)
Reducing X_0*X_2*X_0*X_2+-X_0*X_2
  (12 of 12)
  (Pass 1)
Reducing X_0*X_2*X_0+-X_0
  (1 of 4)
  (Pass 2)
Reducing X_2*X_0*X_2+-X_2
  (2 of 4)
  (Pass 2)
Reducing X_0^2
  (3 of 4)
  (Pass 2)
Reducing X_2^2
  (4 of 4)
  (Pass 2)
Reducing X_0*X_2*X_0+-X_0
  (1 of 4)
  (Pass 1)
Reducing X_2*X_0*X_2+-X_2
  (2 of 4)
  (Pass 1)
Reducing X_0^2
  (3 of 4)
  (Pass 1)
Reducing X_2^2
  (4 of 4)
  (Pass 1)

                                 2    2
o67 = {X X X +-X , X X X +-X , X  , X  }
        0 2 0   0   2 0 2   2   0    2

o67 : List</code></pre>
</td>          </tr>
        </table>
        <div>
          <p>We see a substantial reduction in the number of relations and that X_1 and X_3 are redundant generators. The endomorphisms themselves are cached, and can be accessed via <a title="Methods for creating endomorphism rings of modules over a commutative ring" href="_endomorphism__Ring.html">endomorphismRingGens</a>. As an example, we explicitly verify that X_3 is redundant.</p>
        </div>
        <table class="examples">
          <tr>
<td>              <pre><code class="language-macaulay2">i68 : maps = B.cache.endomorphismRingGens

o68 = {{4} | 0 0 1 0 |, {4} | 0 0 0 0 |, {4} | 0 0 0 0 |, {4} | 1 0 0 0 |}
       {4} | 0 0 0 0 |  {4} | 0 1 0 0 |  {4} | 0 0 0 1 |  {4} | 0 0 0 0 |
       {4} | 0 0 0 0 |  {4} | 0 0 1 0 |  {4} | 1 0 0 0 |  {4} | 0 0 0 0 |
       {4} | 0 1 0 0 |  {4} | 0 0 0 0 |  {4} | 0 0 0 0 |  {4} | 0 0 0 1 |

o68 : List</code></pre>
</td>          </tr>
          <tr>
<td>              <pre><code class="language-macaulay2">i69 : maps#3 == maps#0*maps#2

o69 = true</code></pre>
</td>          </tr>
        </table>
      </div>
    </div>
  </body>

</html>
